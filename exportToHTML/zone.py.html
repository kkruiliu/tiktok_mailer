<html>
<head>
<title>zone.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
zone.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>

<span class="s0"># Copyright (C) 2003-2007, 2009-2011 Nominum, Inc.</span>
<span class="s0">#</span>
<span class="s0"># Permission to use, copy, modify, and distribute this software and its</span>
<span class="s0"># documentation for any purpose with or without fee is hereby granted,</span>
<span class="s0"># provided that the above copyright notice and this permission notice</span>
<span class="s0"># appear in all copies.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="s0"># WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="s0"># ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="s0"># WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="s0"># ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="s0"># OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>

<span class="s2">&quot;&quot;&quot;DNS Zones.&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">import </span><span class="s1">io</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">struct</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">Callable</span><span class="s4">,</span>
    <span class="s1">Iterable</span><span class="s4">,</span>
    <span class="s1">Iterator</span><span class="s4">,</span>
    <span class="s1">List</span><span class="s4">,</span>
    <span class="s1">MutableMapping</span><span class="s4">,</span>
    <span class="s1">Optional</span><span class="s4">,</span>
    <span class="s1">Set</span><span class="s4">,</span>
    <span class="s1">Tuple</span><span class="s4">,</span>
    <span class="s1">Union</span><span class="s4">,</span>
<span class="s4">)</span>

<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">grange</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">immutable</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdata</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdtypes</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">.</span><span class="s1">SOA</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdtypes</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">.</span><span class="s1">ZONEMD</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rrset</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">tokenizer</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">transaction</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">ttl</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">zonefile</span>
<span class="s3">from </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">zonetypes </span><span class="s3">import </span><span class="s1">DigestHashAlgorithm</span><span class="s4">, </span><span class="s1">DigestScheme</span><span class="s4">, </span><span class="s1">_digest_hashers</span>


<span class="s3">class </span><span class="s1">BadZone</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The DNS zone is malformed.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NoSOA</span><span class="s4">(</span><span class="s1">BadZone</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The DNS zone has no SOA RR at its origin.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NoNS</span><span class="s4">(</span><span class="s1">BadZone</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The DNS zone has no NS RRset at its origin.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">UnknownOrigin</span><span class="s4">(</span><span class="s1">BadZone</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The DNS zone's origin is unknown.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">UnsupportedDigestScheme</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The zone digest's scheme is unsupported.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">UnsupportedDigestHashAlgorithm</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The zone digest's origin is unsupported.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NoDigest</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The DNS zone has no ZONEMD RRset at its origin.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">DigestVerificationFailure</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The ZONEMD digest failed to verify.&quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">_validate_name</span><span class="s4">(</span>
    <span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">,</span>
    <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">],</span>
    <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">:</span>
    <span class="s0"># This name validation code is shared by Zone and Version</span>
    <span class="s3">if </span><span class="s1">origin </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s0"># This should probably never happen as other code (e.g.</span>
        <span class="s0"># _rr_line) will notice the lack of an origin before us, but</span>
        <span class="s0"># we check just in case!</span>
        <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s5">&quot;no zone origin is defined&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">name</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
        <span class="s3">if not </span><span class="s1">name</span><span class="s4">.</span><span class="s1">is_subdomain</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s5">&quot;name parameter must be a subdomain of the zone origin&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">relativize</span><span class="s4">:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">name</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s0"># We have a relative name.  Make sure that the derelativized name is</span>
        <span class="s0"># not too long.</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">abs_name </span><span class="s4">= </span><span class="s1">name</span><span class="s4">.</span><span class="s1">derelativize</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">NameTooLong</span><span class="s4">:</span>
            <span class="s0"># We map dns.name.NameTooLong to KeyError to be consistent with</span>
            <span class="s0"># the other exceptions above.</span>
            <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s5">&quot;relative name too long for zone&quot;</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">relativize</span><span class="s4">:</span>
            <span class="s0"># We have a relative name in a non-relative zone, so use the</span>
            <span class="s0"># derelativized name.</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">abs_name</span>
    <span class="s3">return </span><span class="s1">name</span>


<span class="s3">class </span><span class="s1">Zone</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">TransactionManager</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A DNS zone. 
 
    A ``Zone`` is a mapping from names to nodes.  The zone object may be 
    treated like a Python dictionary, e.g. ``zone[name]`` will retrieve 
    the node associated with that name.  The *name* may be a 
    ``dns.name.Name object``, or it may be a string.  In either case, 
    if the name is relative it is treated as relative to the origin of 
    the zone. 
    &quot;&quot;&quot;</span>

    <span class="s1">node_factory</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[], </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span>
    <span class="s1">map_factory</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[], </span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">]] = </span><span class="s1">dict</span>
    <span class="s1">writable_version_factory</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[[], </span><span class="s5">&quot;WritableVersion&quot;</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s1">immutable_version_factory</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[[], </span><span class="s5">&quot;ImmutableVersion&quot;</span><span class="s4">]] = </span><span class="s3">None</span>

    <span class="s1">__slots__ </span><span class="s4">= [</span><span class="s5">&quot;rdclass&quot;</span><span class="s4">, </span><span class="s5">&quot;origin&quot;</span><span class="s4">, </span><span class="s5">&quot;nodes&quot;</span><span class="s4">, </span><span class="s5">&quot;relativize&quot;</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]],</span>
        <span class="s1">rdclass</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">RdataClass </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">IN</span><span class="s4">,</span>
        <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Initialize a zone object. 
 
        *origin* is the origin of the zone.  It may be a ``dns.name.Name``, 
        a ``str``, or ``None``.  If ``None``, then the zone's origin will 
        be set by the first ``$ORIGIN`` line in a zone file. 
 
        *rdclass*, an ``int``, the zone's rdata class; the default is class IN. 
 
        *relativize*, a ``bool``, determine's whether domain names are 
        relativized to the zone's origin.  The default is ``True``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">origin </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
                <span class="s1">origin </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">from_text</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
            <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;origin parameter must be convertible to a DNS name&quot;</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">origin</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;origin parameter must be an absolute name&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">= </span><span class="s1">origin</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass </span><span class="s4">= </span><span class="s1">rdclass</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">: </span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">map_factory</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">relativize </span><span class="s4">= </span><span class="s1">relativize</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Two zones are equal if they have the same origin, class, and 
        nodes. 
 
        Returns a ``bool``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Zone</span><span class="s4">):</span>
            <span class="s3">return False</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass </span><span class="s4">!= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">rdclass</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">!= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">origin</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes </span><span class="s4">!= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">nodes</span>
        <span class="s4">):</span>
            <span class="s3">return False</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">__ne__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Are two zones not equal? 
 
        Returns a ``bool``. 
        &quot;&quot;&quot;</span>

        <span class="s3">return not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">:</span>
        <span class="s0"># Note that any changes in this method should have corresponding changes</span>
        <span class="s0"># made in the Version _validate_name() method.</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">from_text</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s5">&quot;name parameter must be convertible to a DNS name&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">):</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__setitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__delitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">):</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">__iter__</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">keys</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">items</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">):</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__contains__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">):</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span>

    <span class="s3">def </span><span class="s1">find_node</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], </span><span class="s1">create</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Find a node in the zone, possibly creating it. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        *create*, a ``bool``.  If true, the node will be created if it does 
        not exist. 
 
        Raises ``KeyError`` if the name is not known and create was 
        not specified, or if the name was not a subdomain of the origin. 
 
        Returns a ``dns.node.Node``. 
        &quot;&quot;&quot;</span>

        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">node </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">create</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">KeyError</span>
            <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">node_factory</span><span class="s4">()</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">node</span>
        <span class="s3">return </span><span class="s1">node</span>

    <span class="s3">def </span><span class="s1">get_node</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], </span><span class="s1">create</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Get a node in the zone, possibly creating it. 
 
        This method is like ``find_node()``, except it returns None instead 
        of raising an exception if the node does not exist and creation 
        has not been requested. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        *create*, a ``bool``.  If true, the node will be created if it does 
        not exist. 
 
        Returns a ``dns.node.Node`` or ``None``. 
        &quot;&quot;&quot;</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">find_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">create</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s1">node </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">node</span>

    <span class="s3">def </span><span class="s1">delete_node</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Delete the specified node if it exists. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        It is not an error if the node does not exist. 
        &quot;&quot;&quot;</span>

        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">:</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">find_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
        <span class="s1">create</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone, 
        and return an rdataset encapsulating it. 
 
        The rdataset returned is not a copy; changes to it will change 
        the zone. 
 
        KeyError is raised if the name or type are not found. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired. 
 
        *covers*, a ``dns.rdatatype.RdataType`` or ``str`` the covered type. 
        Usually this value is ``dns.rdatatype.NONE``, but if the 
        rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, 
        then the covers value will be the rdata type the SIG/RRSIG 
        covers.  The library treats the SIG and RRSIG types as if they 
        were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). 
        This makes RRSIGs much easier to work with than if RRSIGs 
        covering different rdata types were aggregated into a single 
        RRSIG rdataset. 
 
        *create*, a ``bool``.  If true, the node will be created if it does 
        not exist. 
 
        Raises ``KeyError`` if the name is not known and create was 
        not specified, or if the name was not a subdomain of the origin. 
 
        Returns a ``dns.rdataset.Rdataset``. 
        &quot;&quot;&quot;</span>

        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">rdtype </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">rdtype</span><span class="s4">)</span>
        <span class="s1">covers </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">find_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">create</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">node</span><span class="s4">.</span><span class="s1">find_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">, </span><span class="s1">create</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
        <span class="s1">create</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone. 
 
        This method is like ``find_rdataset()``, except it returns None instead 
        of raising an exception if the rdataset does not exist and creation 
        has not been requested. 
 
        The rdataset returned is not a copy; changes to it will change 
        the zone. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired. 
 
        *covers*, a ``dns.rdatatype.RdataType`` or ``str``, the covered type. 
        Usually this value is ``dns.rdatatype.NONE``, but if the 
        rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, 
        then the covers value will be the rdata type the SIG/RRSIG 
        covers.  The library treats the SIG and RRSIG types as if they 
        were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). 
        This makes RRSIGs much easier to work with than if RRSIGs 
        covering different rdata types were aggregated into a single 
        RRSIG rdataset. 
 
        *create*, a ``bool``.  If true, the node will be created if it does 
        not exist. 
 
        Raises ``KeyError`` if the name is not known and create was 
        not specified, or if the name was not a subdomain of the origin. 
 
        Returns a ``dns.rdataset.Rdataset`` or ``None``. 
        &quot;&quot;&quot;</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">rdataset </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">find_rdataset</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">, </span><span class="s1">create</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s1">rdataset </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">rdataset</span>

    <span class="s3">def </span><span class="s1">delete_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Delete the rdataset matching *rdtype* and *covers*, if it 
        exists at the node specified by *name*. 
 
        It is not an error if the node does not exist, or if there is no matching 
        rdataset at the node. 
 
        If the node has no rdatasets after the deletion, it will itself be deleted. 
 
        *name*: the name of the node to find. The value may be a ``dns.name.Name`` or a 
        ``str``.  If absolute, the name must be a subdomain of the zone's origin.  If 
        ``zone.relativize`` is ``True``, then the name will be relativized. 
 
        *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired. 
 
        *covers*, a ``dns.rdatatype.RdataType`` or ``str`` or ``None``, the covered 
        type. Usually this value is ``dns.rdatatype.NONE``, but if the rdtype is 
        ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, then the covers value will be 
        the rdata type the SIG/RRSIG covers.  The library treats the SIG and RRSIG types 
        as if they were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). This 
        makes RRSIGs much easier to work with than if RRSIGs covering different rdata 
        types were aggregated into a single RRSIG rdataset. 
        &quot;&quot;&quot;</span>

        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">rdtype </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">rdtype</span><span class="s4">)</span>
        <span class="s1">covers </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">node </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">node</span><span class="s4">.</span><span class="s1">delete_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">node</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">delete_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">replace_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], </span><span class="s1">replacement</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Replace an rdataset at name. 
 
        It is not an error if there is no rdataset matching I{replacement}. 
 
        Ownership of the *replacement* object is transferred to the zone; 
        in other words, this method does not store a copy of *replacement* 
        at the node, it stores *replacement* itself. 
 
        If the node does not exist, it is created. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        *replacement*, a ``dns.rdataset.Rdataset``, the replacement rdataset. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">replacement</span><span class="s4">.</span><span class="s1">rdclass </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;replacement.rdclass != zone.rdclass&quot;</span><span class="s4">)</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">find_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s3">True</span><span class="s4">)</span>
        <span class="s1">node</span><span class="s4">.</span><span class="s1">replace_rdataset</span><span class="s4">(</span><span class="s1">replacement</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">find_rrset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">RRset</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone, 
        and return an RRset encapsulating it. 
 
        This method is less efficient than the similar 
        ``find_rdataset()`` because it creates an RRset instead of 
        returning the matching rdataset.  It may be more convenient 
        for some uses since it returns an object which binds the owner 
        name to the rdataset. 
 
        This method may not be used to create new nodes or rdatasets; 
        use ``find_rdataset`` instead. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        *rdtype*, a ``dns.rdatatype.RdataType`` or ``str``, the rdata type desired. 
 
        *covers*, a ``dns.rdatatype.RdataType`` or ``str``, the covered type. 
        Usually this value is ``dns.rdatatype.NONE``, but if the 
        rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, 
        then the covers value will be the rdata type the SIG/RRSIG 
        covers.  The library treats the SIG and RRSIG types as if they 
        were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). 
        This makes RRSIGs much easier to work with than if RRSIGs 
        covering different rdata types were aggregated into a single 
        RRSIG rdataset. 
 
        *create*, a ``bool``.  If true, the node will be created if it does 
        not exist. 
 
        Raises ``KeyError`` if the name is not known and create was 
        not specified, or if the name was not a subdomain of the origin. 
 
        Returns a ``dns.rrset.RRset`` or ``None``. 
        &quot;&quot;&quot;</span>

        <span class="s1">vname </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">rdtype </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">rdtype</span><span class="s4">)</span>
        <span class="s1">covers </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s1">rdataset </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">vname</span><span class="s4">].</span><span class="s1">find_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s1">rrset </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">RRset</span><span class="s4">(</span><span class="s1">vname</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s1">rrset</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">rdataset</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">rrset</span>

    <span class="s3">def </span><span class="s1">get_rrset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">RRset</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Look for an rdataset with the specified name and type in the zone, 
        and return an RRset encapsulating it. 
 
        This method is less efficient than the similar ``get_rdataset()`` 
        because it creates an RRset instead of returning the matching 
        rdataset.  It may be more convenient for some uses since it 
        returns an object which binds the owner name to the rdataset. 
 
        This method may not be used to create new nodes or rdatasets; 
        use ``get_rdataset()`` instead. 
 
        *name*: the name of the node to find. 
        The value may be a ``dns.name.Name`` or a ``str``.  If absolute, the 
        name must be a subdomain of the zone's origin.  If ``zone.relativize`` 
        is ``True``, then the name will be relativized. 
 
        *rdtype*, a ``dns.rdataset.Rdataset`` or ``str``, the rdata type desired. 
 
        *covers*, a ``dns.rdataset.Rdataset`` or ``str``, the covered type. 
        Usually this value is ``dns.rdatatype.NONE``, but if the 
        rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, 
        then the covers value will be the rdata type the SIG/RRSIG 
        covers.  The library treats the SIG and RRSIG types as if they 
        were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). 
        This makes RRSIGs much easier to work with than if RRSIGs 
        covering different rdata types were aggregated into a single 
        RRSIG rdataset. 
 
        *create*, a ``bool``.  If true, the node will be created if it does 
        not exist. 
 
        Returns a ``dns.rrset.RRset`` or ``None``. 
        &quot;&quot;&quot;</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">rrset </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">find_rrset</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s1">rrset </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">rrset</span>

    <span class="s3">def </span><span class="s1">iterate_rdatasets</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return a generator which yields (name, rdataset) tuples for 
        all rdatasets in the zone which have the specified *rdtype* 
        and *covers*.  If *rdtype* is ``dns.rdatatype.ANY``, the default, 
        then all rdatasets will be matched. 
 
        *rdtype*, a ``dns.rdataset.Rdataset`` or ``str``, the rdata type desired. 
 
        *covers*, a ``dns.rdataset.Rdataset`` or ``str``, the covered type. 
        Usually this value is ``dns.rdatatype.NONE``, but if the 
        rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, 
        then the covers value will be the rdata type the SIG/RRSIG 
        covers.  The library treats the SIG and RRSIG types as if they 
        were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). 
        This makes RRSIGs much easier to work with than if RRSIGs 
        covering different rdata types were aggregated into a single 
        RRSIG rdataset. 
        &quot;&quot;&quot;</span>

        <span class="s1">rdtype </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">rdtype</span><span class="s4">)</span>
        <span class="s1">covers </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">node </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">rds </span><span class="s3">in </span><span class="s1">node</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">rdtype </span><span class="s4">== </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">ANY </span><span class="s3">or </span><span class="s4">(</span>
                    <span class="s1">rds</span><span class="s4">.</span><span class="s1">rdtype </span><span class="s4">== </span><span class="s1">rdtype </span><span class="s3">and </span><span class="s1">rds</span><span class="s4">.</span><span class="s1">covers </span><span class="s4">== </span><span class="s1">covers</span>
                <span class="s4">):</span>
                    <span class="s3">yield </span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rds</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">iterate_rdatas</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">int</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdata</span><span class="s4">.</span><span class="s1">Rdata</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return a generator which yields (name, ttl, rdata) tuples for 
        all rdatas in the zone which have the specified *rdtype* 
        and *covers*.  If *rdtype* is ``dns.rdatatype.ANY``, the default, 
        then all rdatas will be matched. 
 
        *rdtype*, a ``dns.rdataset.Rdataset`` or ``str``, the rdata type desired. 
 
        *covers*, a ``dns.rdataset.Rdataset`` or ``str``, the covered type. 
        Usually this value is ``dns.rdatatype.NONE``, but if the 
        rdtype is ``dns.rdatatype.SIG`` or ``dns.rdatatype.RRSIG``, 
        then the covers value will be the rdata type the SIG/RRSIG 
        covers.  The library treats the SIG and RRSIG types as if they 
        were a family of types, e.g. RRSIG(A), RRSIG(NS), RRSIG(SOA). 
        This makes RRSIGs much easier to work with than if RRSIGs 
        covering different rdata types were aggregated into a single 
        RRSIG rdataset. 
        &quot;&quot;&quot;</span>

        <span class="s1">rdtype </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">rdtype</span><span class="s4">)</span>
        <span class="s1">covers </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">.</span><span class="s1">make</span><span class="s4">(</span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">node </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">rds </span><span class="s3">in </span><span class="s1">node</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">rdtype </span><span class="s4">== </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">ANY </span><span class="s3">or </span><span class="s4">(</span>
                    <span class="s1">rds</span><span class="s4">.</span><span class="s1">rdtype </span><span class="s4">== </span><span class="s1">rdtype </span><span class="s3">and </span><span class="s1">rds</span><span class="s4">.</span><span class="s1">covers </span><span class="s4">== </span><span class="s1">covers</span>
                <span class="s4">):</span>
                    <span class="s3">for </span><span class="s1">rdata </span><span class="s3">in </span><span class="s1">rds</span><span class="s4">:</span>
                        <span class="s3">yield </span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rds</span><span class="s4">.</span><span class="s1">ttl</span><span class="s4">, </span><span class="s1">rdata</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_file</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">f</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">sorted</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">nl</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">want_comments</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">want_origin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Write a zone to a file. 
 
        *f*, a file or `str`.  If *f* is a string, it is treated 
        as the name of a file to open. 
 
        *sorted*, a ``bool``.  If True, the default, then the file 
        will be written with the names sorted in DNSSEC order from 
        least to greatest.  Otherwise the names will be written in 
        whatever order they happen to have in the zone's dictionary. 
 
        *relativize*, a ``bool``.  If True, the default, then domain 
        names in the output will be relativized to the zone's origin 
        if possible. 
 
        *nl*, a ``str`` or None.  The end of line string.  If not 
        ``None``, the output will use the platform's native 
        end-of-line marker (i.e. LF on POSIX, CRLF on Windows). 
 
        *want_comments*, a ``bool``.  If ``True``, emit end-of-line comments 
        as part of writing the file.  If ``False``, the default, do not 
        emit them. 
 
        *want_origin*, a ``bool``.  If ``True``, emit a $ORIGIN line at 
        the start of the file.  If ``False``, the default, do not emit 
        one. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s1">cm</span><span class="s4">: </span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">AbstractContextManager </span><span class="s4">= </span><span class="s1">open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;wb&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">cm </span><span class="s4">= </span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">nullcontext</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
        <span class="s3">with </span><span class="s1">cm </span><span class="s3">as </span><span class="s1">f</span><span class="s4">:</span>
            <span class="s0"># must be in this way, f.encoding may contain None, or even</span>
            <span class="s0"># attribute may not be there</span>
            <span class="s1">file_enc </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;encoding&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">file_enc </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">file_enc </span><span class="s4">= </span><span class="s5">&quot;utf-8&quot;</span>

            <span class="s3">if </span><span class="s1">nl </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s0"># binary mode, '\n' is not enough</span>
                <span class="s1">nl_b </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">linesep</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s1">file_enc</span><span class="s4">)</span>
                <span class="s1">nl </span><span class="s4">= </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span>
            <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">nl</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
                <span class="s1">nl_b </span><span class="s4">= </span><span class="s1">nl</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s1">file_enc</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">nl_b </span><span class="s4">= </span><span class="s1">nl</span>
                <span class="s1">nl </span><span class="s4">= </span><span class="s1">nl</span><span class="s4">.</span><span class="s1">decode</span><span class="s4">()</span>

            <span class="s3">if </span><span class="s1">want_origin</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is not None</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s5">&quot;$ORIGIN &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">.</span><span class="s1">to_text</span><span class="s4">()</span>
                <span class="s1">l_b </span><span class="s4">= </span><span class="s1">l</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s1">file_enc</span><span class="s4">)</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">l_b</span><span class="s4">)</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">nl_b</span><span class="s4">)</span>
                <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:  </span><span class="s0"># textual mode</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">l</span><span class="s4">)</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">nl</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">sorted</span><span class="s4">:</span>
                <span class="s1">names </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
                <span class="s1">names</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">()</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">names </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">names</span><span class="s4">:</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">self</span><span class="s4">[</span><span class="s1">n</span><span class="s4">].</span><span class="s1">to_text</span><span class="s4">(</span>
                    <span class="s1">n</span><span class="s4">,</span>
                    <span class="s1">origin</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">,</span>
                    <span class="s1">relativize</span><span class="s4">=</span><span class="s1">relativize</span><span class="s4">,</span>
                    <span class="s1">want_comments</span><span class="s4">=</span><span class="s1">want_comments</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s1">l_b </span><span class="s4">= </span><span class="s1">l</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s1">file_enc</span><span class="s4">)</span>

                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">l_b</span><span class="s4">)</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">nl_b</span><span class="s4">)</span>
                <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:  </span><span class="s0"># textual mode</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">l</span><span class="s4">)</span>
                    <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">nl</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_text</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">sorted</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">nl</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">want_comments</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">want_origin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a zone's text as though it were written to a file. 
 
        *sorted*, a ``bool``.  If True, the default, then the file 
        will be written with the names sorted in DNSSEC order from 
        least to greatest.  Otherwise the names will be written in 
        whatever order they happen to have in the zone's dictionary. 
 
        *relativize*, a ``bool``.  If True, the default, then domain 
        names in the output will be relativized to the zone's origin 
        if possible. 
 
        *nl*, a ``str`` or None.  The end of line string.  If not 
        ``None``, the output will use the platform's native 
        end-of-line marker (i.e. LF on POSIX, CRLF on Windows). 
 
        *want_comments*, a ``bool``.  If ``True``, emit end-of-line comments 
        as part of writing the file.  If ``False``, the default, do not 
        emit them. 
 
        *want_origin*, a ``bool``.  If ``True``, emit a $ORIGIN line at 
        the start of the output.  If ``False``, the default, do not emit 
        one. 
 
        Returns a ``str``. 
        &quot;&quot;&quot;</span>
        <span class="s1">temp_buffer </span><span class="s4">= </span><span class="s1">io</span><span class="s4">.</span><span class="s1">StringIO</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">to_file</span><span class="s4">(</span><span class="s1">temp_buffer</span><span class="s4">, </span><span class="s1">sorted</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">, </span><span class="s1">nl</span><span class="s4">, </span><span class="s1">want_comments</span><span class="s4">, </span><span class="s1">want_origin</span><span class="s4">)</span>
        <span class="s1">return_value </span><span class="s4">= </span><span class="s1">temp_buffer</span><span class="s4">.</span><span class="s1">getvalue</span><span class="s4">()</span>
        <span class="s1">temp_buffer</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">return_value</span>

    <span class="s3">def </span><span class="s1">check_origin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Do some simple checking of the zone's origin. 
 
        Raises ``dns.zone.NoSOA`` if there is no SOA RRset. 
 
        Raises ``dns.zone.NoNS`` if there is no NS RRset. 
 
        Raises ``KeyError`` if there is no origin node. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">empty</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is not None</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_rdataset</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">SOA</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NoSOA</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_rdataset</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NS</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NoNS</span>

    <span class="s3">def </span><span class="s1">get_soa</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">txn</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">Transaction</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">rdtypes</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">.</span><span class="s1">SOA</span><span class="s4">.</span><span class="s1">SOA</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Get the zone SOA rdata. 
 
        Raises ``dns.zone.NoSOA`` if there is no SOA RRset. 
 
        Returns a ``dns.rdtypes.ANY.SOA.SOA`` Rdata. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">:</span>
            <span class="s1">origin_name </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">empty</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s0"># get_soa() has been called very early, and there must not be</span>
                <span class="s0"># an SOA if there is no origin.</span>
                <span class="s3">raise </span><span class="s1">NoSOA</span>
            <span class="s1">origin_name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span>
        <span class="s1">soa</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">txn</span><span class="s4">:</span>
            <span class="s1">soa </span><span class="s4">= </span><span class="s1">txn</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">origin_name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">SOA</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">soa </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_rdataset</span><span class="s4">(</span><span class="s1">origin_name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">SOA</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">soa </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NoSOA</span>
        <span class="s3">return </span><span class="s1">soa</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_compute_digest</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">hash_algorithm</span><span class="s4">: </span><span class="s1">DigestHashAlgorithm</span><span class="s4">,</span>
        <span class="s1">scheme</span><span class="s4">: </span><span class="s1">DigestScheme </span><span class="s4">= </span><span class="s1">DigestScheme</span><span class="s4">.</span><span class="s1">SIMPLE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; bytes</span><span class="s4">:</span>
        <span class="s1">hashinfo </span><span class="s4">= </span><span class="s1">_digest_hashers</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">hash_algorithm</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">hashinfo</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">UnsupportedDigestHashAlgorithm</span>
        <span class="s3">if </span><span class="s1">scheme </span><span class="s4">!= </span><span class="s1">DigestScheme</span><span class="s4">.</span><span class="s1">SIMPLE</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">UnsupportedDigestScheme</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">:</span>
            <span class="s1">origin_name </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">empty</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is not None</span>
            <span class="s1">origin_name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span>
        <span class="s1">hasher </span><span class="s4">= </span><span class="s1">hashinfo</span><span class="s4">()</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">node </span><span class="s3">in </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
            <span class="s1">rrnamebuf </span><span class="s4">= </span><span class="s1">name</span><span class="s4">.</span><span class="s1">to_digestable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">rdataset </span><span class="s3">in </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">key</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">rds</span><span class="s4">: (</span><span class="s1">rds</span><span class="s4">.</span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">rds</span><span class="s4">.</span><span class="s1">covers</span><span class="s4">)):</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s4">== </span><span class="s1">origin_name </span><span class="s3">and </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">ZONEMD </span><span class="s3">in </span><span class="s4">(</span>
                    <span class="s1">rdataset</span><span class="s4">.</span><span class="s1">rdtype</span><span class="s4">,</span>
                    <span class="s1">rdataset</span><span class="s4">.</span><span class="s1">covers</span><span class="s4">,</span>
                <span class="s4">):</span>
                    <span class="s3">continue</span>
                <span class="s1">rrfixed </span><span class="s4">= </span><span class="s1">struct</span><span class="s4">.</span><span class="s1">pack</span><span class="s4">(</span>
                    <span class="s5">&quot;!HHI&quot;</span><span class="s4">, </span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">ttl</span>
                <span class="s4">)</span>
                <span class="s1">rdatas </span><span class="s4">= [</span><span class="s1">rdata</span><span class="s4">.</span><span class="s1">to_digestable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">) </span><span class="s3">for </span><span class="s1">rdata </span><span class="s3">in </span><span class="s1">rdataset</span><span class="s4">]</span>
                <span class="s3">for </span><span class="s1">rdata </span><span class="s3">in </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">rdatas</span><span class="s4">):</span>
                    <span class="s1">rrlen </span><span class="s4">= </span><span class="s1">struct</span><span class="s4">.</span><span class="s1">pack</span><span class="s4">(</span><span class="s5">&quot;!H&quot;</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">rdata</span><span class="s4">))</span>
                    <span class="s1">hasher</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">rrnamebuf </span><span class="s4">+ </span><span class="s1">rrfixed </span><span class="s4">+ </span><span class="s1">rrlen </span><span class="s4">+ </span><span class="s1">rdata</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">hasher</span><span class="s4">.</span><span class="s1">digest</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">compute_digest</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">hash_algorithm</span><span class="s4">: </span><span class="s1">DigestHashAlgorithm</span><span class="s4">,</span>
        <span class="s1">scheme</span><span class="s4">: </span><span class="s1">DigestScheme </span><span class="s4">= </span><span class="s1">DigestScheme</span><span class="s4">.</span><span class="s1">SIMPLE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">rdtypes</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">:</span>
        <span class="s1">serial </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_soa</span><span class="s4">().</span><span class="s1">serial</span>
        <span class="s1">digest </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compute_digest</span><span class="s4">(</span><span class="s1">hash_algorithm</span><span class="s4">, </span><span class="s1">scheme</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdtypes</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">, </span><span class="s1">serial</span><span class="s4">, </span><span class="s1">scheme</span><span class="s4">, </span><span class="s1">hash_algorithm</span><span class="s4">, </span><span class="s1">digest</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">verify_digest</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">zonemd</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdtypes</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">digests</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdtypes</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">]]</span>
        <span class="s3">if </span><span class="s1">zonemd</span><span class="s4">:</span>
            <span class="s1">digests </span><span class="s4">= [</span><span class="s1">zonemd</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is not None</span>
            <span class="s1">rds </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">ZONEMD</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">rds </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">NoDigest</span>
            <span class="s1">digests </span><span class="s4">= </span><span class="s1">rds</span>
        <span class="s3">for </span><span class="s1">digest </span><span class="s3">in </span><span class="s1">digests</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">computed </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compute_digest</span><span class="s4">(</span><span class="s1">digest</span><span class="s4">.</span><span class="s1">hash_algorithm</span><span class="s4">, </span><span class="s1">digest</span><span class="s4">.</span><span class="s1">scheme</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">computed </span><span class="s4">== </span><span class="s1">digest</span><span class="s4">.</span><span class="s1">digest</span><span class="s4">:</span>
                    <span class="s3">return</span>
            <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                <span class="s3">pass</span>
        <span class="s3">raise </span><span class="s1">DigestVerificationFailure</span>

    <span class="s0"># TransactionManager methods</span>

    <span class="s3">def </span><span class="s1">reader</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Transaction&quot;</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">Transaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s1">Version</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">writer</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">replacement</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Transaction&quot;</span><span class="s4">:</span>
        <span class="s1">txn </span><span class="s4">= </span><span class="s1">Transaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">replacement</span><span class="s4">)</span>
        <span class="s1">txn</span><span class="s4">.</span><span class="s1">_setup_version</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">txn</span>

    <span class="s3">def </span><span class="s1">origin_information</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">], </span><span class="s1">bool</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">]]:</span>
        <span class="s1">effective</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">:</span>
            <span class="s1">effective </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">empty</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">effective </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">, </span><span class="s1">effective</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_class</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">rdclass</span>

    <span class="s0"># Transaction methods</span>

    <span class="s3">def </span><span class="s1">_end_read</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">txn</span><span class="s4">):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_end_write</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">txn</span><span class="s4">):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_commit_version</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">version</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes </span><span class="s4">= </span><span class="s1">version</span><span class="s4">.</span><span class="s1">nodes</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">= </span><span class="s1">origin</span>

    <span class="s3">def </span><span class="s1">_get_next_version_id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># Versions are ephemeral and all have id 1</span>
        <span class="s3">return </span><span class="s6">1</span>


<span class="s0"># These classes used to be in dns.versioned, but have moved here so we can use</span>
<span class="s0"># the copy-on-write transaction mechanism for both kinds of zones.  In a</span>
<span class="s0"># regular zone, the version only exists during the transaction, and the nodes</span>
<span class="s0"># are regular dns.node.Nodes.</span>

<span class="s0"># A node with a version id.</span>


<span class="s3">class </span><span class="s1">VersionedNode</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">):  </span><span class="s0"># lgtm[py/missing-equals]</span>
    <span class="s1">__slots__ </span><span class="s4">= [</span><span class="s5">&quot;id&quot;</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s0"># A proper id will get set by the Version</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">id </span><span class="s4">= </span><span class="s6">0</span>


<span class="s4">@</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">immutable</span><span class="s4">.</span><span class="s1">immutable</span>
<span class="s3">class </span><span class="s1">ImmutableVersionedNode</span><span class="s4">(</span><span class="s1">VersionedNode</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">node</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">id </span><span class="s4">= </span><span class="s1">node</span><span class="s4">.</span><span class="s1">id</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">rdatasets </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span>
            <span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">ImmutableRdataset</span><span class="s4">(</span><span class="s1">rds</span><span class="s4">) </span><span class="s3">for </span><span class="s1">rds </span><span class="s3">in </span><span class="s1">node</span><span class="s4">.</span><span class="s1">rdatasets</span><span class="s4">]</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">find_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">rdclass</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">RdataClass</span><span class="s4">,</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">,</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
        <span class="s1">create</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">create</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;immutable&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">find_rdataset</span><span class="s4">(</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">rdclass</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">RdataClass</span><span class="s4">,</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">,</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
        <span class="s1">create</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">create</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;immutable&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">get_rdataset</span><span class="s4">(</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">delete_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">rdclass</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">RdataClass</span><span class="s4">,</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">,</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;immutable&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">replace_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">replacement</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;immutable&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">is_immutable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return True</span>


<span class="s3">class </span><span class="s1">Version</span><span class="s4">:</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">zone</span><span class="s4">: </span><span class="s1">Zone</span><span class="s4">,</span>
        <span class="s1">id</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
        <span class="s1">nodes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">zone </span><span class="s4">= </span><span class="s1">zone</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">id </span><span class="s4">= </span><span class="s1">id</span>
        <span class="s3">if </span><span class="s1">nodes </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes </span><span class="s4">= </span><span class="s1">nodes</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes </span><span class="s4">= </span><span class="s1">zone</span><span class="s4">.</span><span class="s1">map_factory</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">= </span><span class="s1">origin</span>

    <span class="s3">def </span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_node</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">]:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">,</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">,</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span><span class="s4">]:</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">node </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">node</span><span class="s4">.</span><span class="s1">get_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">keys</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">items</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">WritableVersion</span><span class="s4">(</span><span class="s1">Version</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">zone</span><span class="s4">: </span><span class="s1">Zone</span><span class="s4">, </span><span class="s1">replacement</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">):</span>
        <span class="s0"># The zone._versions_lock must be held by our caller in a versioned</span>
        <span class="s0"># zone.</span>
        <span class="s1">id </span><span class="s4">= </span><span class="s1">zone</span><span class="s4">.</span><span class="s1">_get_next_version_id</span><span class="s4">()</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">zone</span><span class="s4">, </span><span class="s1">id</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">replacement</span><span class="s4">:</span>
            <span class="s0"># We copy the map, because that gives us a simple and thread-safe</span>
            <span class="s0"># way of doing versions, and we have a garbage collector to help</span>
            <span class="s0"># us.  We only make new node objects if we actually change the</span>
            <span class="s0"># node.</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">)</span>
        <span class="s0"># We have to copy the zone origin as it may be None in the first</span>
        <span class="s0"># version, and we don't want to mutate the zone until we commit.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">= </span><span class="s1">zone</span><span class="s4">.</span><span class="s1">origin</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">changed</span><span class="s4">: </span><span class="s1">Set</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">] = </span><span class="s1">set</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_maybe_cow</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">node</span><span class="s4">.</span><span class="s1">Node</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">node </span><span class="s3">is None or </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">changed</span><span class="s4">:</span>
            <span class="s1">new_node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">node_factory</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">new_node</span><span class="s4">, </span><span class="s5">&quot;id&quot;</span><span class="s4">):</span>
                <span class="s0"># We keep doing this for backwards compatibility, as earlier</span>
                <span class="s0"># code used new_node.id != self.id for the &quot;do we need to CoW?&quot;</span>
                <span class="s0"># test.  Now we use the changed set as this works with both</span>
                <span class="s0"># regular zones and versioned zones.</span>
                <span class="s0">#</span>
                <span class="s0"># We ignore the mypy error as this is safe but it doesn't see it.</span>
                <span class="s1">new_node</span><span class="s4">.</span><span class="s1">id </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">id  </span><span class="s0"># type: ignore</span>
            <span class="s3">if </span><span class="s1">node </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s0"># moo!  copy on write!</span>
                <span class="s1">new_node</span><span class="s4">.</span><span class="s1">rdatasets</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">rdatasets</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">new_node</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">changed</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">new_node</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">node</span>

    <span class="s3">def </span><span class="s1">delete_node</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">:</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">changed</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">put_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">rdataset</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataset</span><span class="s4">.</span><span class="s1">Rdataset</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_maybe_cow</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">node</span><span class="s4">.</span><span class="s1">replace_rdataset</span><span class="s4">(</span><span class="s1">rdataset</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">delete_rdataset</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">,</span>
        <span class="s1">rdtype</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">,</span>
        <span class="s1">covers</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdatatype</span><span class="s4">.</span><span class="s1">RdataType</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_maybe_cow</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">node</span><span class="s4">.</span><span class="s1">delete_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">node</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>


<span class="s4">@</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">immutable</span><span class="s4">.</span><span class="s1">immutable</span>
<span class="s3">class </span><span class="s1">ImmutableVersion</span><span class="s4">(</span><span class="s1">Version</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">version</span><span class="s4">: </span><span class="s1">WritableVersion</span><span class="s4">):</span>
        <span class="s0"># We tell super() that it's a replacement as we don't want it</span>
        <span class="s0"># to copy the nodes, as we're about to do that with an</span>
        <span class="s0"># immutable Dict.</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">version</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">, </span><span class="s3">True</span><span class="s4">)</span>
        <span class="s0"># set the right id!</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">id </span><span class="s4">= </span><span class="s1">version</span><span class="s4">.</span><span class="s1">id</span>
        <span class="s0"># keep the origin</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">= </span><span class="s1">version</span><span class="s4">.</span><span class="s1">origin</span>
        <span class="s0"># Make changed nodes immutable</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">version</span><span class="s4">.</span><span class="s1">changed</span><span class="s4">:</span>
            <span class="s1">node </span><span class="s4">= </span><span class="s1">version</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s0"># it might not exist if we deleted it in the version</span>
            <span class="s3">if </span><span class="s1">node</span><span class="s4">:</span>
                <span class="s1">version</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">ImmutableVersionedNode</span><span class="s4">(</span><span class="s1">node</span><span class="s4">)</span>
        <span class="s0"># We're changing the type of the nodes dictionary here on purpose, so</span>
        <span class="s0"># we ignore the mypy error.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">nodes </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">immutable</span><span class="s4">.</span><span class="s1">Dict</span><span class="s4">(</span>
            <span class="s1">version</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">, </span><span class="s3">True</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">map_factory</span>
        <span class="s4">)  </span><span class="s0"># type: ignore</span>


<span class="s3">class </span><span class="s1">Transaction</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">Transaction</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">zone</span><span class="s4">, </span><span class="s1">replacement</span><span class="s4">, </span><span class="s1">version</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">make_immutable</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s1">read_only </span><span class="s4">= </span><span class="s1">version </span><span class="s3">is not None</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">zone</span><span class="s4">, </span><span class="s1">replacement</span><span class="s4">, </span><span class="s1">read_only</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">version </span><span class="s4">= </span><span class="s1">version</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">make_immutable </span><span class="s4">= </span><span class="s1">make_immutable</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">zone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">manager</span>

    <span class="s3">def </span><span class="s1">_setup_version</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version </span><span class="s3">is None</span>
        <span class="s1">factory </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">writable_version_factory</span>
        <span class="s3">if </span><span class="s1">factory </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">factory </span><span class="s4">= </span><span class="s1">WritableVersion</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">version </span><span class="s4">= </span><span class="s1">factory</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">replacement</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">get_rdataset</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_put_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdataset</span><span class="s4">):</span>
        <span class="s3">assert not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">read_only</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">put_rdataset</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdataset</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_delete_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s3">assert not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">read_only</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">delete_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_delete_rdataset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">):</span>
        <span class="s3">assert not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">read_only</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">delete_rdataset</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">covers</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_name_exists</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">get_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">) </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">_changed</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">read_only</span><span class="s4">:</span>
            <span class="s3">return False</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">changed</span><span class="s4">) &gt; </span><span class="s6">0</span>

    <span class="s3">def </span><span class="s1">_end_transaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">commit</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">read_only</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">_end_read</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">commit </span><span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">changed</span><span class="s4">) &gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">make_immutable</span><span class="s4">:</span>
                <span class="s1">factory </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">immutable_version_factory</span>
                <span class="s3">if </span><span class="s1">factory </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s1">factory </span><span class="s4">= </span><span class="s1">ImmutableVersion</span>
                <span class="s1">version </span><span class="s4">= </span><span class="s1">factory</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">version </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">_commit_version</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">version</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">origin</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># rollback</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">_end_write</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_set_origin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">= </span><span class="s1">origin</span>

    <span class="s3">def </span><span class="s1">_iterate_rdatasets</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">node </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">rdataset </span><span class="s3">in </span><span class="s1">node</span><span class="s4">:</span>
                <span class="s3">yield </span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">rdataset</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_iterate_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_node</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">get_node</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_origin_information</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s4">(</span><span class="s1">absolute</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">, </span><span class="s1">effective</span><span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">origin_information</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">absolute </span><span class="s3">is None and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s0"># No origin has been committed yet, but we've learned one as part of</span>
            <span class="s0"># this txn.  Use it.</span>
            <span class="s1">absolute </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">version</span><span class="s4">.</span><span class="s1">origin</span>
            <span class="s3">if </span><span class="s1">relativize</span><span class="s4">:</span>
                <span class="s1">effective </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">empty</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">effective </span><span class="s4">= </span><span class="s1">absolute</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">absolute</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">, </span><span class="s1">effective</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_from_text</span><span class="s4">(</span>
    <span class="s1">text</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">rdclass</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">RdataClass </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">IN</span><span class="s4">,</span>
    <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">zone_factory</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s1">Zone</span><span class="s4">,</span>
    <span class="s1">filename</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">allow_include</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">check_origin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">IDNACodec</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">allow_directives</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Zone</span><span class="s4">:</span>
    <span class="s0"># See the comments for the public APIs from_text() and from_file() for</span>
    <span class="s0"># details.</span>

    <span class="s0"># 'text' can also be a file, but we don't publish that fact</span>
    <span class="s0"># since it's an implementation detail.  The official file</span>
    <span class="s0"># interface is from_file().</span>

    <span class="s3">if </span><span class="s1">filename </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">filename </span><span class="s4">= </span><span class="s5">&quot;&lt;string&gt;&quot;</span>
    <span class="s1">zone </span><span class="s4">= </span><span class="s1">zone_factory</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">=</span><span class="s1">relativize</span><span class="s4">)</span>
    <span class="s3">with </span><span class="s1">zone</span><span class="s4">.</span><span class="s1">writer</span><span class="s4">(</span><span class="s3">True</span><span class="s4">) </span><span class="s3">as </span><span class="s1">txn</span><span class="s4">:</span>
        <span class="s1">tok </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">tokenizer</span><span class="s4">.</span><span class="s1">Tokenizer</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">filename</span><span class="s4">, </span><span class="s1">idna_codec</span><span class="s4">=</span><span class="s1">idna_codec</span><span class="s4">)</span>
        <span class="s1">reader </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">zonefile</span><span class="s4">.</span><span class="s1">Reader</span><span class="s4">(</span>
            <span class="s1">tok</span><span class="s4">,</span>
            <span class="s1">rdclass</span><span class="s4">,</span>
            <span class="s1">txn</span><span class="s4">,</span>
            <span class="s1">allow_include</span><span class="s4">=</span><span class="s1">allow_include</span><span class="s4">,</span>
            <span class="s1">allow_directives</span><span class="s4">=</span><span class="s1">allow_directives</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">reader</span><span class="s4">.</span><span class="s1">read</span><span class="s4">()</span>
        <span class="s3">except </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">zonefile</span><span class="s4">.</span><span class="s1">UnknownOrigin</span><span class="s4">:</span>
            <span class="s0"># for backwards compatibility</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">zone</span><span class="s4">.</span><span class="s1">UnknownOrigin</span>
    <span class="s0"># Now that we're done reading, do some basic checking of the zone.</span>
    <span class="s3">if </span><span class="s1">check_origin</span><span class="s4">:</span>
        <span class="s1">zone</span><span class="s4">.</span><span class="s1">check_origin</span><span class="s4">()</span>
    <span class="s3">return </span><span class="s1">zone</span>


<span class="s3">def </span><span class="s1">from_text</span><span class="s4">(</span>
    <span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">rdclass</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">RdataClass </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">IN</span><span class="s4">,</span>
    <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">zone_factory</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s1">Zone</span><span class="s4">,</span>
    <span class="s1">filename</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">allow_include</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">check_origin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">IDNACodec</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">allow_directives</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Zone</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Build a zone object from a zone file format string. 
 
    *text*, a ``str``, the zone file format input. 
 
    *origin*, a ``dns.name.Name``, a ``str``, or ``None``.  The origin 
    of the zone; if not specified, the first ``$ORIGIN`` statement in the 
    zone file will determine the origin of the zone. 
 
    *rdclass*, a ``dns.rdataclass.RdataClass``, the zone's rdata class; the default is 
    class IN. 
 
    *relativize*, a ``bool``, determine's whether domain names are 
    relativized to the zone's origin.  The default is ``True``. 
 
    *zone_factory*, the zone factory to use or ``None``.  If ``None``, then 
    ``dns.zone.Zone`` will be used.  The value may be any class or callable 
    that returns a subclass of ``dns.zone.Zone``. 
 
    *filename*, a ``str`` or ``None``, the filename to emit when 
    describing where an error occurred; the default is ``'&lt;string&gt;'``. 
 
    *allow_include*, a ``bool``.  If ``True``, the default, then ``$INCLUDE`` 
    directives are permitted.  If ``False``, then encoutering a ``$INCLUDE`` 
    will raise a ``SyntaxError`` exception. 
 
    *check_origin*, a ``bool``.  If ``True``, the default, then sanity 
    checks of the origin node will be made by calling the zone's 
    ``check_origin()`` method. 
 
    *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA 
    encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder 
    is used. 
 
    *allow_directives*, a ``bool`` or an iterable of `str`.  If ``True``, the default, 
    then directives are permitted, and the *allow_include* parameter controls whether 
    ``$INCLUDE`` is permitted.  If ``False`` or an empty iterable, then no directive 
    processing is done and any directive-like text will be treated as a regular owner 
    name.  If a non-empty iterable, then only the listed directives (including the 
    ``$``) are allowed. 
 
    Raises ``dns.zone.NoSOA`` if there is no SOA RRset. 
 
    Raises ``dns.zone.NoNS`` if there is no NS RRset. 
 
    Raises ``KeyError`` if there is no origin node. 
 
    Returns a subclass of ``dns.zone.Zone``. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_from_text</span><span class="s4">(</span>
        <span class="s1">text</span><span class="s4">,</span>
        <span class="s1">origin</span><span class="s4">,</span>
        <span class="s1">rdclass</span><span class="s4">,</span>
        <span class="s1">relativize</span><span class="s4">,</span>
        <span class="s1">zone_factory</span><span class="s4">,</span>
        <span class="s1">filename</span><span class="s4">,</span>
        <span class="s1">allow_include</span><span class="s4">,</span>
        <span class="s1">check_origin</span><span class="s4">,</span>
        <span class="s1">idna_codec</span><span class="s4">,</span>
        <span class="s1">allow_directives</span><span class="s4">,</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">from_file</span><span class="s4">(</span>
    <span class="s1">f</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">rdclass</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">RdataClass </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">rdataclass</span><span class="s4">.</span><span class="s1">IN</span><span class="s4">,</span>
    <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">zone_factory</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s1">Zone</span><span class="s4">,</span>
    <span class="s1">filename</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">allow_include</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">check_origin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">IDNACodec</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">allow_directives</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Zone</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Read a zone file and build a zone object. 
 
    *f*, a file or ``str``.  If *f* is a string, it is treated 
    as the name of a file to open. 
 
    *origin*, a ``dns.name.Name``, a ``str``, or ``None``.  The origin 
    of the zone; if not specified, the first ``$ORIGIN`` statement in the 
    zone file will determine the origin of the zone. 
 
    *rdclass*, an ``int``, the zone's rdata class; the default is class IN. 
 
    *relativize*, a ``bool``, determine's whether domain names are 
    relativized to the zone's origin.  The default is ``True``. 
 
    *zone_factory*, the zone factory to use or ``None``.  If ``None``, then 
    ``dns.zone.Zone`` will be used.  The value may be any class or callable 
    that returns a subclass of ``dns.zone.Zone``. 
 
    *filename*, a ``str`` or ``None``, the filename to emit when 
    describing where an error occurred; the default is ``'&lt;string&gt;'``. 
 
    *allow_include*, a ``bool``.  If ``True``, the default, then ``$INCLUDE`` 
    directives are permitted.  If ``False``, then encoutering a ``$INCLUDE`` 
    will raise a ``SyntaxError`` exception. 
 
    *check_origin*, a ``bool``.  If ``True``, the default, then sanity 
    checks of the origin node will be made by calling the zone's 
    ``check_origin()`` method. 
 
    *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA 
    encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder 
    is used. 
 
    *allow_directives*, a ``bool`` or an iterable of `str`.  If ``True``, the default, 
    then directives are permitted, and the *allow_include* parameter controls whether 
    ``$INCLUDE`` is permitted.  If ``False`` or an empty iterable, then no directive 
    processing is done and any directive-like text will be treated as a regular owner 
    name.  If a non-empty iterable, then only the listed directives (including the 
    ``$``) are allowed. 
 
    Raises ``dns.zone.NoSOA`` if there is no SOA RRset. 
 
    Raises ``dns.zone.NoNS`` if there is no NS RRset. 
 
    Raises ``KeyError`` if there is no origin node. 
 
    Returns a subclass of ``dns.zone.Zone``. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">filename </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">filename </span><span class="s4">= </span><span class="s1">f</span>
        <span class="s1">cm</span><span class="s4">: </span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">AbstractContextManager </span><span class="s4">= </span><span class="s1">open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">cm </span><span class="s4">= </span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">nullcontext</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s3">with </span><span class="s1">cm </span><span class="s3">as </span><span class="s1">f</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_from_text</span><span class="s4">(</span>
            <span class="s1">f</span><span class="s4">,</span>
            <span class="s1">origin</span><span class="s4">,</span>
            <span class="s1">rdclass</span><span class="s4">,</span>
            <span class="s1">relativize</span><span class="s4">,</span>
            <span class="s1">zone_factory</span><span class="s4">,</span>
            <span class="s1">filename</span><span class="s4">,</span>
            <span class="s1">allow_include</span><span class="s4">,</span>
            <span class="s1">check_origin</span><span class="s4">,</span>
            <span class="s1">idna_codec</span><span class="s4">,</span>
            <span class="s1">allow_directives</span><span class="s4">,</span>
        <span class="s4">)</span>
    <span class="s3">assert False  </span><span class="s0"># make mypy happy  lgtm[py/unreachable-statement]</span>


<span class="s3">def </span><span class="s1">from_xfr</span><span class="s4">(</span>
    <span class="s1">xfr</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">zone_factory</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s1">Zone</span><span class="s4">,</span>
    <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">check_origin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Zone</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Convert the output of a zone transfer generator into a zone object. 
 
    *xfr*, a generator of ``dns.message.Message`` objects, typically 
    ``dns.query.xfr()``. 
 
    *relativize*, a ``bool``, determine's whether domain names are 
    relativized to the zone's origin.  The default is ``True``. 
    It is essential that the relativize setting matches the one specified 
    to the generator. 
 
    *check_origin*, a ``bool``.  If ``True``, the default, then sanity 
    checks of the origin node will be made by calling the zone's 
    ``check_origin()`` method. 
 
    Raises ``dns.zone.NoSOA`` if there is no SOA RRset. 
 
    Raises ``dns.zone.NoNS`` if there is no NS RRset. 
 
    Raises ``KeyError`` if there is no origin node. 
 
    Raises ``ValueError`` if no messages are yielded by the generator. 
 
    Returns a subclass of ``dns.zone.Zone``. 
    &quot;&quot;&quot;</span>

    <span class="s1">z </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">xfr</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">z </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">relativize</span><span class="s4">:</span>
                <span class="s1">origin </span><span class="s4">= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">origin</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">origin </span><span class="s4">= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">answer</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">name</span>
            <span class="s1">rdclass </span><span class="s4">= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">answer</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">rdclass</span>
            <span class="s1">z </span><span class="s4">= </span><span class="s1">zone_factory</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">=</span><span class="s1">relativize</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">rrset </span><span class="s3">in </span><span class="s1">r</span><span class="s4">.</span><span class="s1">answer</span><span class="s4">:</span>
            <span class="s1">znode </span><span class="s4">= </span><span class="s1">z</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">znode</span><span class="s4">:</span>
                <span class="s1">znode </span><span class="s4">= </span><span class="s1">z</span><span class="s4">.</span><span class="s1">node_factory</span><span class="s4">()</span>
                <span class="s1">z</span><span class="s4">.</span><span class="s1">nodes</span><span class="s4">[</span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">znode</span>
            <span class="s1">zrds </span><span class="s4">= </span><span class="s1">znode</span><span class="s4">.</span><span class="s1">find_rdataset</span><span class="s4">(</span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">rdclass</span><span class="s4">, </span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">rdtype</span><span class="s4">, </span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">covers</span><span class="s4">, </span><span class="s3">True</span><span class="s4">)</span>
            <span class="s1">zrds</span><span class="s4">.</span><span class="s1">update_ttl</span><span class="s4">(</span><span class="s1">rrset</span><span class="s4">.</span><span class="s1">ttl</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">rd </span><span class="s3">in </span><span class="s1">rrset</span><span class="s4">:</span>
                <span class="s1">zrds</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">rd</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">z </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;empty transfer&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">check_origin</span><span class="s4">:</span>
        <span class="s1">z</span><span class="s4">.</span><span class="s1">check_origin</span><span class="s4">()</span>
    <span class="s3">return </span><span class="s1">z</span>
</pre>
</body>
</html>