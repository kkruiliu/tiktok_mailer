<html>
<head>
<title>tokenizer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tokenizer.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>

<span class="s0"># Copyright (C) 2003-2017 Nominum, Inc.</span>
<span class="s0">#</span>
<span class="s0"># Permission to use, copy, modify, and distribute this software and its</span>
<span class="s0"># documentation for any purpose with or without fee is hereby granted,</span>
<span class="s0"># provided that the above copyright notice and this permission notice</span>
<span class="s0"># appear in all copies.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="s0"># WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="s0"># ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="s0"># WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="s0"># ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="s0"># OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>

<span class="s2">&quot;&quot;&quot;Tokenize DNS zone file format&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">io</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">List</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">, </span><span class="s1">Tuple</span>

<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">ttl</span>

<span class="s1">_DELIMITERS </span><span class="s4">= {</span><span class="s5">&quot; &quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\t</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s5">&quot;;&quot;</span><span class="s4">, </span><span class="s5">&quot;(&quot;</span><span class="s4">, </span><span class="s5">&quot;)&quot;</span><span class="s4">, </span><span class="s5">'&quot;'</span><span class="s4">}</span>
<span class="s1">_QUOTING_DELIMITERS </span><span class="s4">= {</span><span class="s5">'&quot;'</span><span class="s4">}</span>

<span class="s1">EOF </span><span class="s4">= </span><span class="s6">0</span>
<span class="s1">EOL </span><span class="s4">= </span><span class="s6">1</span>
<span class="s1">WHITESPACE </span><span class="s4">= </span><span class="s6">2</span>
<span class="s1">IDENTIFIER </span><span class="s4">= </span><span class="s6">3</span>
<span class="s1">QUOTED_STRING </span><span class="s4">= </span><span class="s6">4</span>
<span class="s1">COMMENT </span><span class="s4">= </span><span class="s6">5</span>
<span class="s1">DELIMITER </span><span class="s4">= </span><span class="s6">6</span>


<span class="s3">class </span><span class="s1">UngetBufferFull</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An attempt was made to unget a token when the unget buffer was full.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">Token</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A DNS zone file format token. 
 
    ttype: The token type 
    value: The token value 
    has_escape: Does the token value contain escapes? 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">ttype</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
        <span class="s1">value</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s5">&quot;&quot;</span><span class="s4">,</span>
        <span class="s1">has_escape</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">comment</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Initialize a token instance.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">= </span><span class="s1">ttype</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">has_escape </span><span class="s4">= </span><span class="s1">has_escape</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">comment </span><span class="s4">= </span><span class="s1">comment</span>

    <span class="s3">def </span><span class="s1">is_eof</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">EOF</span>

    <span class="s3">def </span><span class="s1">is_eol</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">EOL</span>

    <span class="s3">def </span><span class="s1">is_whitespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">WHITESPACE</span>

    <span class="s3">def </span><span class="s1">is_identifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">IDENTIFIER</span>

    <span class="s3">def </span><span class="s1">is_quoted_string</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">QUOTED_STRING</span>

    <span class="s3">def </span><span class="s1">is_comment</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">COMMENT</span>

    <span class="s3">def </span><span class="s1">is_delimiter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:  </span><span class="s0"># pragma: no cover (we don't return delimiters yet)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">DELIMITER</span>

    <span class="s3">def </span><span class="s1">is_eol_or_eof</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">EOL </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">EOF</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Token</span><span class="s4">):</span>
            <span class="s3">return False</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">ttype </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__ne__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Token</span><span class="s4">):</span>
            <span class="s3">return True</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype </span><span class="s4">!= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">ttype </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value </span><span class="s4">!= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">'%d &quot;%s&quot;' </span><span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">unescape</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Token&quot;</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">has_escape</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s1">unescaped </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
        <span class="s1">l </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">l</span><span class="s4">:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">&quot;</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">l</span><span class="s4">:  </span><span class="s0"># pragma: no cover   (can't happen via get())</span>
                    <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
                <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">():</span>
                    <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">l</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
                    <span class="s1">c2 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
                    <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">l</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
                    <span class="s1">c3 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
                    <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">if not </span><span class="s4">(</span><span class="s1">c2</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">() </span><span class="s3">and </span><span class="s1">c3</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">()):</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span>
                    <span class="s1">codepoint </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) * </span><span class="s6">100 </span><span class="s4">+ </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c2</span><span class="s4">) * </span><span class="s6">10 </span><span class="s4">+ </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c3</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">codepoint </span><span class="s4">&gt; </span><span class="s6">255</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span>
                    <span class="s1">c </span><span class="s4">= </span><span class="s1">chr</span><span class="s4">(</span><span class="s1">codepoint</span><span class="s4">)</span>
            <span class="s1">unescaped </span><span class="s4">+= </span><span class="s1">c</span>
        <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype</span><span class="s4">, </span><span class="s1">unescaped</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">unescape_to_bytes</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Token&quot;</span><span class="s4">:</span>
        <span class="s0"># We used to use unescape() for TXT-like records, but this</span>
        <span class="s0"># caused problems as we'd process DNS escapes into Unicode code</span>
        <span class="s0"># points instead of byte values, and then a to_text() of the</span>
        <span class="s0"># processed data would not equal the original input.  For</span>
        <span class="s0"># example, \226 in the TXT record would have a to_text() of</span>
        <span class="s0"># \195\162 because we applied UTF-8 encoding to Unicode code</span>
        <span class="s0"># point 226.</span>
        <span class="s0">#</span>
        <span class="s0"># We now apply escapes while converting directly to bytes,</span>
        <span class="s0"># avoiding this double encoding.</span>
        <span class="s0">#</span>
        <span class="s0"># This code also handles cases where the unicode input has</span>
        <span class="s0"># non-ASCII code-points in it by converting it to UTF-8.  TXT</span>
        <span class="s0"># records aren't defined for Unicode, but this is the best we</span>
        <span class="s0"># can do to preserve meaning.  For example,</span>
        <span class="s0">#</span>
        <span class="s0">#     foo\u200bbar</span>
        <span class="s0">#</span>
        <span class="s0"># (where \u200b is Unicode code point 0x200b) will be treated</span>
        <span class="s0"># as if the input had been the UTF-8 encoding of that string,</span>
        <span class="s0"># namely:</span>
        <span class="s0">#</span>
        <span class="s0">#     foo\226\128\139bar</span>
        <span class="s0">#</span>
        <span class="s1">unescaped </span><span class="s4">= </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">l </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">l</span><span class="s4">:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">&quot;</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">l</span><span class="s4">:  </span><span class="s0"># pragma: no cover   (can't happen via get())</span>
                    <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
                <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">():</span>
                    <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">l</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
                    <span class="s1">c2 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
                    <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">l</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
                    <span class="s1">c3 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
                    <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">if not </span><span class="s4">(</span><span class="s1">c2</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">() </span><span class="s3">and </span><span class="s1">c3</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">()):</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span>
                    <span class="s1">codepoint </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) * </span><span class="s6">100 </span><span class="s4">+ </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c2</span><span class="s4">) * </span><span class="s6">10 </span><span class="s4">+ </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c3</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">codepoint </span><span class="s4">&gt; </span><span class="s6">255</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span>
                    <span class="s1">unescaped </span><span class="s4">+= </span><span class="s7">b&quot;%c&quot; </span><span class="s4">% (</span><span class="s1">codepoint</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s0"># Note that as mentioned above, if c is a Unicode</span>
                    <span class="s0"># code point outside of the ASCII range, then this</span>
                    <span class="s0"># += is converting that code point to its UTF-8</span>
                    <span class="s0"># encoding and appending multiple bytes to</span>
                    <span class="s0"># unescaped.</span>
                    <span class="s1">unescaped </span><span class="s4">+= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">()</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">unescaped </span><span class="s4">+= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">ttype</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">(</span><span class="s1">unescaped</span><span class="s4">))</span>


<span class="s3">class </span><span class="s1">Tokenizer</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A DNS zone file format tokenizer. 
 
    A token object is basically a (type, value) tuple.  The valid 
    types are EOF, EOL, WHITESPACE, IDENTIFIER, QUOTED_STRING, 
    COMMENT, and DELIMITER. 
 
    file: The file to tokenize 
 
    ungotten_char: The most recently ungotten character, or None. 
 
    ungotten_token: The most recently ungotten token, or None. 
 
    multiline: The current multiline level.  This value is increased 
    by one every time a '(' delimiter is read, and decreased by one every time 
    a ')' delimiter is read. 
 
    quoting: This variable is true if the tokenizer is currently 
    reading a quoted string. 
 
    eof: This variable is true if the tokenizer has encountered EOF. 
 
    delimiters: The current delimiter dictionary. 
 
    line_number: The current line number 
 
    filename: A filename that will be returned by the where() method. 
 
    idna_codec: A dns.name.IDNACodec, specifies the IDNA 
    encoder/decoder.  If None, the default IDNA 2003 
    encoder/decoder is used. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">f</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">stdin</span><span class="s4">,</span>
        <span class="s1">filename</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">IDNACodec</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Initialize a tokenizer instance. 
 
        f: The file to tokenize.  The default is sys.stdin. 
        This parameter may also be a string, in which case the tokenizer 
        will take its input from the contents of the string. 
 
        filename: the name of the filename that the where() method 
        will return. 
 
        idna_codec: A dns.name.IDNACodec, specifies the IDNA 
        encoder/decoder.  If None, the default IDNA 2003 
        encoder/decoder is used. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">io</span><span class="s4">.</span><span class="s1">StringIO</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">filename </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">filename </span><span class="s4">= </span><span class="s5">&quot;&lt;string&gt;&quot;</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">):</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">io</span><span class="s4">.</span><span class="s1">StringIO</span><span class="s4">(</span><span class="s1">f</span><span class="s4">.</span><span class="s1">decode</span><span class="s4">())</span>
            <span class="s3">if </span><span class="s1">filename </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">filename </span><span class="s4">= </span><span class="s5">&quot;&lt;string&gt;&quot;</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">filename </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">f </span><span class="s3">is </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">stdin</span><span class="s4">:</span>
                    <span class="s1">filename </span><span class="s4">= </span><span class="s5">&quot;&lt;stdin&gt;&quot;</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">filename </span><span class="s4">= </span><span class="s5">&quot;&lt;file&gt;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">file </span><span class="s4">= </span><span class="s1">f</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_char</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_token</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Token</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">multiline </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">quoting </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">eof </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">delimiters </span><span class="s4">= </span><span class="s1">_DELIMITERS</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">line_number </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s3">assert </span><span class="s1">filename </span><span class="s3">is not None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">filename </span><span class="s4">= </span><span class="s1">filename</span>
        <span class="s3">if </span><span class="s1">idna_codec </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">IDNACodec </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">IDNA_2003</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">idna_codec </span><span class="s4">= </span><span class="s1">idna_codec</span>

    <span class="s3">def </span><span class="s1">_get_char</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read a character from input.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_char </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">eof</span><span class="s4">:</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">file</span><span class="s4">.</span><span class="s1">read</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;&quot;</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">eof </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">line_number </span><span class="s4">+= </span><span class="s6">1</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_char</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_char </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the current location in the input. 
 
        Returns a (string, int) tuple.  The first item is the filename of 
        the input, the second is the current line number. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">line_number</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_unget_char</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">c</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Unget a character. 
 
        The unget buffer for characters is only one character large; it is 
        an error to try to unget a character when the unget buffer is not 
        empty. 
 
        c: the character to unget 
        raises UngetBufferFull: there is already an ungotten char 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_char </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s0"># this should never happen!</span>
            <span class="s3">raise </span><span class="s1">UngetBufferFull  </span><span class="s0"># pragma: no cover</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_char </span><span class="s4">= </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">skip_whitespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Consume input until a non-whitespace character is encountered. 
 
        The non-whitespace character is then ungotten, and the number of 
        whitespace characters consumed is returned. 
 
        If the tokenizer is in multiline mode, then newlines are whitespace. 
 
        Returns the number of characters skipped. 
        &quot;&quot;&quot;</span>

        <span class="s1">skipped </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">while True</span><span class="s4">:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_char</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s4">!= </span><span class="s5">&quot; &quot; </span><span class="s3">and </span><span class="s1">c </span><span class="s4">!= </span><span class="s5">&quot;</span><span class="s3">\t</span><span class="s5">&quot;</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s1">c </span><span class="s4">!= </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">) </span><span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multiline</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_unget_char</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                    <span class="s3">return </span><span class="s1">skipped</span>
            <span class="s1">skipped </span><span class="s4">+= </span><span class="s6">1</span>

    <span class="s3">def </span><span class="s1">get</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">want_leading</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">, </span><span class="s1">want_comment</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; Token</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Get the next token. 
 
        want_leading: If True, return a WHITESPACE token if the 
        first character read is whitespace.  The default is False. 
 
        want_comment: If True, return a COMMENT token if the 
        first token read is a comment.  The default is False. 
 
        Raises dns.exception.UnexpectedEnd: input ended prematurely 
 
        Raises dns.exception.SyntaxError: input was badly formed 
 
        Returns a Token. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_token </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">utoken </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_token</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_token </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">utoken</span><span class="s4">.</span><span class="s1">is_whitespace</span><span class="s4">():</span>
                <span class="s3">if </span><span class="s1">want_leading</span><span class="s4">:</span>
                    <span class="s3">return </span><span class="s1">utoken</span>
            <span class="s3">elif </span><span class="s1">utoken</span><span class="s4">.</span><span class="s1">is_comment</span><span class="s4">():</span>
                <span class="s3">if </span><span class="s1">want_comment</span><span class="s4">:</span>
                    <span class="s3">return </span><span class="s1">utoken</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">utoken</span>
        <span class="s1">skipped </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">skip_whitespace</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">want_leading </span><span class="s3">and </span><span class="s1">skipped </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">WHITESPACE</span><span class="s4">, </span><span class="s5">&quot; &quot;</span><span class="s4">)</span>
        <span class="s1">token </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
        <span class="s1">ttype </span><span class="s4">= </span><span class="s1">IDENTIFIER</span>
        <span class="s1">has_escape </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">while True</span><span class="s4">:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_char</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;&quot; </span><span class="s3">or </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delimiters</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;&quot; </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quoting</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
                <span class="s3">if </span><span class="s1">token </span><span class="s4">== </span><span class="s5">&quot;&quot; </span><span class="s3">and </span><span class="s1">ttype </span><span class="s4">!= </span><span class="s1">QUOTED_STRING</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;(&quot;</span><span class="s4">:</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">multiline </span><span class="s4">+= </span><span class="s6">1</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">skip_whitespace</span><span class="s4">()</span>
                        <span class="s3">continue</span>
                    <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;)&quot;</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multiline </span><span class="s4">&lt;= </span><span class="s6">0</span><span class="s4">:</span>
                            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">multiline </span><span class="s4">-= </span><span class="s6">1</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">skip_whitespace</span><span class="s4">()</span>
                        <span class="s3">continue</span>
                    <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">'&quot;'</span><span class="s4">:</span>
                        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quoting</span><span class="s4">:</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">quoting </span><span class="s4">= </span><span class="s3">True</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">delimiters </span><span class="s4">= </span><span class="s1">_QUOTING_DELIMITERS</span>
                            <span class="s1">ttype </span><span class="s4">= </span><span class="s1">QUOTED_STRING</span>
                            <span class="s3">continue</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">quoting </span><span class="s4">= </span><span class="s3">False</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">delimiters </span><span class="s4">= </span><span class="s1">_DELIMITERS</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">skip_whitespace</span><span class="s4">()</span>
                            <span class="s3">continue</span>
                    <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">:</span>
                        <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">EOL</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">)</span>
                    <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;;&quot;</span><span class="s4">:</span>
                        <span class="s3">while </span><span class="s6">1</span><span class="s4">:</span>
                            <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_char</span><span class="s4">()</span>
                            <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot; </span><span class="s3">or </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;&quot;</span><span class="s4">:</span>
                                <span class="s3">break</span>
                            <span class="s1">token </span><span class="s4">+= </span><span class="s1">c</span>
                        <span class="s3">if </span><span class="s1">want_comment</span><span class="s4">:</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">_unget_char</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                            <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">COMMENT</span><span class="s4">, </span><span class="s1">token</span><span class="s4">)</span>
                        <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;&quot;</span><span class="s4">:</span>
                            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multiline</span><span class="s4">:</span>
                                <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span>
                                    <span class="s5">&quot;unbalanced parentheses&quot;</span>
                                <span class="s4">)</span>
                            <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">EOF</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">=</span><span class="s1">token</span><span class="s4">)</span>
                        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multiline</span><span class="s4">:</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">skip_whitespace</span><span class="s4">()</span>
                            <span class="s1">token </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
                            <span class="s3">continue</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">EOL</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">=</span><span class="s1">token</span><span class="s4">)</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s0"># This code exists in case we ever want a</span>
                        <span class="s0"># delimiter to be returned.  It never produces</span>
                        <span class="s0"># a token currently.</span>
                        <span class="s1">token </span><span class="s4">= </span><span class="s1">c</span>
                        <span class="s1">ttype </span><span class="s4">= </span><span class="s1">DELIMITER</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_unget_char</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                <span class="s3">break</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quoting </span><span class="s3">and </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;newline in quoted string&quot;</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">&quot;</span><span class="s4">:</span>
                <span class="s0">#</span>
                <span class="s0"># It's an escape.  Put it and the next character into</span>
                <span class="s0"># the token; it will be checked later for goodness.</span>
                <span class="s0">#</span>
                <span class="s1">token </span><span class="s4">+= </span><span class="s1">c</span>
                <span class="s1">has_escape </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_char</span><span class="s4">()</span>
                <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;&quot; </span><span class="s3">or </span><span class="s4">(</span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot; </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quoting</span><span class="s4">):</span>
                    <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">UnexpectedEnd</span>
            <span class="s1">token </span><span class="s4">+= </span><span class="s1">c</span>
        <span class="s3">if </span><span class="s1">token </span><span class="s4">== </span><span class="s5">&quot;&quot; </span><span class="s3">and </span><span class="s1">ttype </span><span class="s4">!= </span><span class="s1">QUOTED_STRING</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multiline</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;unbalanced parentheses&quot;</span><span class="s4">)</span>
            <span class="s1">ttype </span><span class="s4">= </span><span class="s1">EOF</span>
        <span class="s3">return </span><span class="s1">Token</span><span class="s4">(</span><span class="s1">ttype</span><span class="s4">, </span><span class="s1">token</span><span class="s4">, </span><span class="s1">has_escape</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">unget</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">token</span><span class="s4">: </span><span class="s1">Token</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Unget a token. 
 
        The unget buffer for tokens is only one token large; it is 
        an error to try to unget a token when the unget buffer is not 
        empty. 
 
        token: the token to unget 
 
        Raises UngetBufferFull: there is already an ungotten token 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_token </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">UngetBufferFull</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ungotten_token </span><span class="s4">= </span><span class="s1">token</span>

    <span class="s3">def </span><span class="s1">next</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Return the next item in an iteration. 
 
        Returns a Token. 
        &quot;&quot;&quot;</span>

        <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_eof</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">StopIteration</span>
        <span class="s3">return </span><span class="s1">token</span>

    <span class="s1">__next__ </span><span class="s4">= </span><span class="s1">next</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s0"># Helpers</span>

    <span class="s3">def </span><span class="s1">get_int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">base</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">10</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as an unsigned integer. 
 
        Raises dns.exception.SyntaxError if not an unsigned integer. 
 
        Returns an int. 
        &quot;&quot;&quot;</span>

        <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">().</span><span class="s1">unescape</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_identifier</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;expecting an identifier&quot;</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;expecting an integer&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">int</span><span class="s4">(</span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span><span class="s4">, </span><span class="s1">base</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_uint8</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as an 8-bit unsigned 
        integer. 
 
        Raises dns.exception.SyntaxError if not an 8-bit unsigned integer. 
 
        Returns an int. 
        &quot;&quot;&quot;</span>

        <span class="s1">value </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_int</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">value </span><span class="s4">&gt; </span><span class="s6">255</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span>
                <span class="s5">&quot;%d is not an unsigned 8-bit integer&quot; </span><span class="s4">% </span><span class="s1">value</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_uint16</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">base</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">10</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as a 16-bit unsigned 
        integer. 
 
        Raises dns.exception.SyntaxError if not a 16-bit unsigned integer. 
 
        Returns an int. 
        &quot;&quot;&quot;</span>

        <span class="s1">value </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_int</span><span class="s4">(</span><span class="s1">base</span><span class="s4">=</span><span class="s1">base</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">value </span><span class="s4">&gt; </span><span class="s6">65535</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">base </span><span class="s4">== </span><span class="s6">8</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span>
                    <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">value</span><span class="s3">:</span><span class="s5">o</span><span class="s3">} </span><span class="s5">is not an octal unsigned 16-bit integer&quot;</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span>
                    <span class="s5">&quot;%d is not an unsigned 16-bit integer&quot; </span><span class="s4">% </span><span class="s1">value</span>
                <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_uint32</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">base</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">10</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as a 32-bit unsigned 
        integer. 
 
        Raises dns.exception.SyntaxError if not a 32-bit unsigned integer. 
 
        Returns an int. 
        &quot;&quot;&quot;</span>

        <span class="s1">value </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_int</span><span class="s4">(</span><span class="s1">base</span><span class="s4">=</span><span class="s1">base</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">value </span><span class="s4">&gt; </span><span class="s6">4294967295</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span>
                <span class="s5">&quot;%d is not an unsigned 32-bit integer&quot; </span><span class="s4">% </span><span class="s1">value</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_uint48</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">base</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">10</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as a 48-bit unsigned 
        integer. 
 
        Raises dns.exception.SyntaxError if not a 48-bit unsigned integer. 
 
        Returns an int. 
        &quot;&quot;&quot;</span>

        <span class="s1">value </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_int</span><span class="s4">(</span><span class="s1">base</span><span class="s4">=</span><span class="s1">base</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">value </span><span class="s4">&gt; </span><span class="s6">281474976710655</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span>
                <span class="s5">&quot;%d is not an unsigned 48-bit integer&quot; </span><span class="s4">% </span><span class="s1">value</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_string</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">max_length</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as a string. 
 
        Raises dns.exception.SyntaxError if not a string. 
        Raises dns.exception.SyntaxError if token value length 
        exceeds max_length (if specified). 
 
        Returns a string. 
        &quot;&quot;&quot;</span>

        <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">().</span><span class="s1">unescape</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_identifier</span><span class="s4">() </span><span class="s3">or </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_quoted_string</span><span class="s4">()):</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;expecting a string&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">max_length </span><span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span><span class="s4">) &gt; </span><span class="s1">max_length</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;string too long&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_identifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token, which should be an identifier. 
 
        Raises dns.exception.SyntaxError if not an identifier. 
 
        Returns a string. 
        &quot;&quot;&quot;</span>

        <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">().</span><span class="s1">unescape</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_identifier</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;expecting an identifier&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_remaining</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">max_tokens</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">Token</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the remaining tokens on the line, until an EOL or EOF is seen. 
 
        max_tokens: If not None, stop after this number of tokens. 
 
        Returns a list of tokens. 
        &quot;&quot;&quot;</span>

        <span class="s1">tokens </span><span class="s4">= []</span>
        <span class="s3">while True</span><span class="s4">:</span>
            <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_eol_or_eof</span><span class="s4">():</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">unget</span><span class="s4">(</span><span class="s1">token</span><span class="s4">)</span>
                <span class="s3">break</span>
            <span class="s1">tokens</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">token</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">tokens</span><span class="s4">) == </span><span class="s1">max_tokens</span><span class="s4">:</span>
                <span class="s3">break</span>
        <span class="s3">return </span><span class="s1">tokens</span>

    <span class="s3">def </span><span class="s1">concatenate_remaining_identifiers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">allow_empty</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the remaining tokens on the line, which should be identifiers. 
 
        Raises dns.exception.SyntaxError if there are no remaining tokens, 
        unless `allow_empty=True` is given. 
 
        Raises dns.exception.SyntaxError if a token is seen that is not an 
        identifier. 
 
        Returns a string containing a concatenation of the remaining 
        identifiers. 
        &quot;&quot;&quot;</span>
        <span class="s1">s </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
        <span class="s3">while True</span><span class="s4">:</span>
            <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">().</span><span class="s1">unescape</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_eol_or_eof</span><span class="s4">():</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">unget</span><span class="s4">(</span><span class="s1">token</span><span class="s4">)</span>
                <span class="s3">break</span>
            <span class="s3">if not </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_identifier</span><span class="s4">():</span>
                <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span>
            <span class="s1">s </span><span class="s4">+= </span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">allow_empty </span><span class="s3">or </span><span class="s1">s</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;expecting another identifier&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">s</span>

    <span class="s3">def </span><span class="s1">as_name</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">token</span><span class="s4">: </span><span class="s1">Token</span><span class="s4">,</span>
        <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">relativize_to</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Try to interpret the token as a DNS name. 
 
        Raises dns.exception.SyntaxError if not a name. 
 
        Returns a dns.name.Name. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_identifier</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;expecting an identifier&quot;</span><span class="s4">)</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">from_text</span><span class="s4">(</span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">idna_codec</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">name</span><span class="s4">.</span><span class="s1">choose_relativity</span><span class="s4">(</span><span class="s1">relativize_to </span><span class="s3">or </span><span class="s1">origin</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_name</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">relativize_to</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as a DNS name. 
 
        Raises dns.exception.SyntaxError if not a name. 
 
        Returns a dns.name.Name. 
        &quot;&quot;&quot;</span>

        <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">as_name</span><span class="s4">(</span><span class="s1">token</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">, </span><span class="s1">relativize_to</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_eol_as_token</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Token</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and raise an exception if it isn't EOL or 
        EOF. 
 
        Returns a string. 
        &quot;&quot;&quot;</span>

        <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_eol_or_eof</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span>
                <span class="s5">'expected EOL or EOF, got %d &quot;%s&quot;' </span><span class="s4">% (</span><span class="s1">token</span><span class="s4">.</span><span class="s1">ttype</span><span class="s4">, </span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">token</span>

    <span class="s3">def </span><span class="s1">get_eol</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_eol_as_token</span><span class="s4">().</span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_ttl</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Read the next token and interpret it as a DNS TTL. 
 
        Raises dns.exception.SyntaxError or dns.ttl.BadTTL if not an 
        identifier or badly formed. 
 
        Returns an int. 
        &quot;&quot;&quot;</span>

        <span class="s1">token </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">().</span><span class="s1">unescape</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s1">token</span><span class="s4">.</span><span class="s1">is_identifier</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">(</span><span class="s5">&quot;expecting an identifier&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">ttl</span><span class="s4">.</span><span class="s1">from_text</span><span class="s4">(</span><span class="s1">token</span><span class="s4">.</span><span class="s1">value</span><span class="s4">)</span>
</pre>
</body>
</html>