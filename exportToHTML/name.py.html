<html>
<head>
<title>name.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
name.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license</span>

<span class="s0"># Copyright (C) 2001-2017 Nominum, Inc.</span>
<span class="s0">#</span>
<span class="s0"># Permission to use, copy, modify, and distribute this software and its</span>
<span class="s0"># documentation for any purpose with or without fee is hereby granted,</span>
<span class="s0"># provided that the above copyright notice and this permission notice</span>
<span class="s0"># appear in all copies.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND NOMINUM DISCLAIMS ALL WARRANTIES</span>
<span class="s0"># WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR</span>
<span class="s0"># ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="s0"># WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="s0"># ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</span>
<span class="s0"># OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>

<span class="s2">&quot;&quot;&quot;DNS Names. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">encodings</span><span class="s4">.</span><span class="s1">idna  </span><span class="s0"># type: ignore</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">struct</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Callable</span><span class="s4">, </span><span class="s1">Dict</span><span class="s4">, </span><span class="s1">Iterable</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">, </span><span class="s1">Tuple</span><span class="s4">, </span><span class="s1">Union</span>

<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">_features</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">enum</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">immutable</span>
<span class="s3">import </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">wire</span>

<span class="s3">if </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">_features</span><span class="s4">.</span><span class="s1">have</span><span class="s4">(</span><span class="s5">&quot;idna&quot;</span><span class="s4">):</span>
    <span class="s3">import </span><span class="s1">idna  </span><span class="s0"># type: ignore</span>

    <span class="s1">have_idna_2008 </span><span class="s4">= </span><span class="s3">True</span>
<span class="s3">else</span><span class="s4">:  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">have_idna_2008 </span><span class="s4">= </span><span class="s3">False</span>

<span class="s1">CompressType </span><span class="s4">= </span><span class="s1">Dict</span><span class="s4">[</span><span class="s5">&quot;Name&quot;</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">NameRelation</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">enum</span><span class="s4">.</span><span class="s1">IntEnum</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Name relation result from fullcompare().&quot;&quot;&quot;</span>

    <span class="s0"># This is an IntEnum for backwards compatibility in case anyone</span>
    <span class="s0"># has hardwired the constants.</span>

    <span class="s0">#: The compared names have no relationship to each other.</span>
    <span class="s1">NONE </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s0">#: the first name is a superdomain of the second.</span>
    <span class="s1">SUPERDOMAIN </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s0">#: The first name is a subdomain of the second.</span>
    <span class="s1">SUBDOMAIN </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s0">#: The compared names are equal.</span>
    <span class="s1">EQUAL </span><span class="s4">= </span><span class="s6">3</span>
    <span class="s0">#: The compared names have a common ancestor.</span>
    <span class="s1">COMMONANCESTOR </span><span class="s4">= </span><span class="s6">4</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_maximum</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">COMMONANCESTOR  </span><span class="s0"># pragma: no cover</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_short_name</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__  </span><span class="s0"># pragma: no cover</span>


<span class="s0"># Backwards compatibility</span>
<span class="s1">NAMERELN_NONE </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">NONE</span>
<span class="s1">NAMERELN_SUPERDOMAIN </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">SUPERDOMAIN</span>
<span class="s1">NAMERELN_SUBDOMAIN </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">SUBDOMAIN</span>
<span class="s1">NAMERELN_EQUAL </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">EQUAL</span>
<span class="s1">NAMERELN_COMMONANCESTOR </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">COMMONANCESTOR</span>


<span class="s3">class </span><span class="s1">EmptyLabel</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A DNS label is empty.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">BadEscape</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An escaped code in a text format of DNS name is invalid.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">BadPointer</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">FormError</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A DNS compression pointer points forward instead of backward.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">BadLabelType</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">FormError</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The label type in DNS name wire format is unknown.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NeedAbsoluteNameOrOrigin</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An attempt was made to convert a non-absolute name to 
    wire when there was also a non-absolute (or missing) origin.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NameTooLong</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">FormError</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A DNS name is &gt; 255 octets long.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">LabelTooLong</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">SyntaxError</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A DNS label is &gt; 63 octets long.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">AbsoluteConcatenation</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An attempt was made to append anything other than the 
    empty name to an absolute DNS name.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NoParent</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An attempt was made to get the parent of the root name 
    or the empty name.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">NoIDNA2008</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;IDNA 2008 processing was requested but the idna module is not 
    available.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">IDNAException</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;IDNA processing raised an exception.&quot;&quot;&quot;</span>

    <span class="s1">supp_kwargs </span><span class="s4">= {</span><span class="s5">&quot;idna_exception&quot;</span><span class="s4">}</span>
    <span class="s1">fmt </span><span class="s4">= </span><span class="s5">&quot;IDNA processing exception: {idna_exception}&quot;</span>

    <span class="s0"># We do this as otherwise mypy complains about unexpected keyword argument</span>
    <span class="s0"># idna_exception</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">NeedSubdomainOfOrigin</span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">exception</span><span class="s4">.</span><span class="s1">DNSException</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An absolute name was provided that is not a subdomain of the specified origin.&quot;&quot;&quot;</span>


<span class="s1">_escaped </span><span class="s4">= </span><span class="s7">b'&quot;().;</span><span class="s3">\\</span><span class="s7">@$'</span>
<span class="s1">_escaped_text </span><span class="s4">= </span><span class="s5">'&quot;().;</span><span class="s3">\\</span><span class="s5">@$'</span>


<span class="s3">def </span><span class="s1">_escapify</span><span class="s4">(</span><span class="s1">label</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Escape the characters in label which need it. 
    @returns: the escaped string 
    @rtype: string&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">):</span>
        <span class="s0"># Ordinary DNS label mode.  Escape special characters and values</span>
        <span class="s0"># &lt; 0x20 or &gt; 0x7f.</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">label</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s3">in </span><span class="s1">_escaped</span><span class="s4">:</span>
                <span class="s1">text </span><span class="s4">+= </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">&quot; </span><span class="s4">+ </span><span class="s1">chr</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">c </span><span class="s4">&gt; </span><span class="s6">0x20 </span><span class="s3">and </span><span class="s1">c </span><span class="s4">&lt; </span><span class="s6">0x7F</span><span class="s4">:</span>
                <span class="s1">text </span><span class="s4">+= </span><span class="s1">chr</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">text </span><span class="s4">+= </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">%03d&quot; </span><span class="s4">% </span><span class="s1">c</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s0"># Unicode label mode.  Escape only special characters and values &lt; 0x20</span>
    <span class="s1">text </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">uc </span><span class="s3">in </span><span class="s1">label</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">uc </span><span class="s3">in </span><span class="s1">_escaped_text</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">&quot; </span><span class="s4">+ </span><span class="s1">uc</span>
        <span class="s3">elif </span><span class="s1">uc </span><span class="s4">&lt;= </span><span class="s5">&quot;</span><span class="s3">\x20</span><span class="s5">&quot;</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">%03d&quot; </span><span class="s4">% </span><span class="s1">ord</span><span class="s4">(</span><span class="s1">uc</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s1">uc</span>
    <span class="s3">return </span><span class="s1">text</span>


<span class="s3">class </span><span class="s1">IDNACodec</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Abstract base class for IDNA encoder/decoders.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">is_idna</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">label</span><span class="s4">: </span><span class="s1">bytes</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">label</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">startswith</span><span class="s4">(</span><span class="s7">b&quot;xn--&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">encode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">label</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bytes</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError  </span><span class="s0"># pragma: no cover</span>

    <span class="s3">def </span><span class="s1">decode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">label</span><span class="s4">: </span><span class="s1">bytes</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s0"># We do not apply any IDNA policy on decode.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_idna</span><span class="s4">(</span><span class="s1">label</span><span class="s4">):</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">slabel </span><span class="s4">= </span><span class="s1">label</span><span class="s4">[</span><span class="s6">4</span><span class="s4">:].</span><span class="s1">decode</span><span class="s4">(</span><span class="s5">&quot;punycode&quot;</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">_escapify</span><span class="s4">(</span><span class="s1">slabel</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">IDNAException</span><span class="s4">(</span><span class="s1">idna_exception</span><span class="s4">=</span><span class="s1">e</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_escapify</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">IDNA2003Codec</span><span class="s4">(</span><span class="s1">IDNACodec</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;IDNA 2003 encoder/decoder.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">strict_decode</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Initialize the IDNA 2003 encoder/decoder. 
 
        *strict_decode* is a ``bool``. If `True`, then IDNA2003 checking 
        is done when decoding.  This can cause failures if the name 
        was encoded with IDNA2008.  The default is `False`. 
        &quot;&quot;&quot;</span>

        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">strict_decode </span><span class="s4">= </span><span class="s1">strict_decode</span>

    <span class="s3">def </span><span class="s1">encode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">label</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bytes</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Encode *label*.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">label </span><span class="s4">== </span><span class="s5">&quot;&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s7">b&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">encodings</span><span class="s4">.</span><span class="s1">idna</span><span class="s4">.</span><span class="s1">ToASCII</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">UnicodeError</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">LabelTooLong</span>

    <span class="s3">def </span><span class="s1">decode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">label</span><span class="s4">: </span><span class="s1">bytes</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Decode *label*.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">strict_decode</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">decode</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">label </span><span class="s4">== </span><span class="s7">b&quot;&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_escapify</span><span class="s4">(</span><span class="s1">encodings</span><span class="s4">.</span><span class="s1">idna</span><span class="s4">.</span><span class="s1">ToUnicode</span><span class="s4">(</span><span class="s1">label</span><span class="s4">))</span>
        <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">IDNAException</span><span class="s4">(</span><span class="s1">idna_exception</span><span class="s4">=</span><span class="s1">e</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">IDNA2008Codec</span><span class="s4">(</span><span class="s1">IDNACodec</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;IDNA 2008 encoder/decoder.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">uts_46</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">transitional</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">allow_pure_ascii</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">strict_decode</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Initialize the IDNA 2008 encoder/decoder. 
 
        *uts_46* is a ``bool``.  If True, apply Unicode IDNA 
        compatibility processing as described in Unicode Technical 
        Standard #46 (https://unicode.org/reports/tr46/). 
        If False, do not apply the mapping.  The default is False. 
 
        *transitional* is a ``bool``: If True, use the 
        &quot;transitional&quot; mode described in Unicode Technical Standard 
        #46.  The default is False. 
 
        *allow_pure_ascii* is a ``bool``.  If True, then a label which 
        consists of only ASCII characters is allowed.  This is less 
        strict than regular IDNA 2008, but is also necessary for mixed 
        names, e.g. a name with starting with &quot;_sip._tcp.&quot; and ending 
        in an IDN suffix which would otherwise be disallowed.  The 
        default is False. 
 
        *strict_decode* is a ``bool``: If True, then IDNA2008 checking 
        is done when decoding.  This can cause failures if the name 
        was encoded with IDNA2003.  The default is False. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">uts_46 </span><span class="s4">= </span><span class="s1">uts_46</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transitional </span><span class="s4">= </span><span class="s1">transitional</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">allow_pure_ascii </span><span class="s4">= </span><span class="s1">allow_pure_ascii</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">strict_decode </span><span class="s4">= </span><span class="s1">strict_decode</span>

    <span class="s3">def </span><span class="s1">encode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">label</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bytes</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">label </span><span class="s4">== </span><span class="s5">&quot;&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s7">b&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">allow_pure_ascii </span><span class="s3">and </span><span class="s1">is_all_ascii</span><span class="s4">(</span><span class="s1">label</span><span class="s4">):</span>
            <span class="s1">encoded </span><span class="s4">= </span><span class="s1">label</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s5">&quot;ascii&quot;</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">encoded</span><span class="s4">) &gt; </span><span class="s6">63</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">LabelTooLong</span>
            <span class="s3">return </span><span class="s1">encoded</span>
        <span class="s3">if not </span><span class="s1">have_idna_2008</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NoIDNA2008</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">uts_46</span><span class="s4">:</span>
                <span class="s0"># pylint: disable=possibly-used-before-assignment</span>
                <span class="s1">label </span><span class="s4">= </span><span class="s1">idna</span><span class="s4">.</span><span class="s1">uts46_remap</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transitional</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">idna</span><span class="s4">.</span><span class="s1">alabel</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">idna</span><span class="s4">.</span><span class="s1">IDNAError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">e</span><span class="s4">.</span><span class="s1">args</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s5">&quot;Label too long&quot;</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">LabelTooLong</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">IDNAException</span><span class="s4">(</span><span class="s1">idna_exception</span><span class="s4">=</span><span class="s1">e</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">decode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">label</span><span class="s4">: </span><span class="s1">bytes</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">strict_decode</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">decode</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">label </span><span class="s4">== </span><span class="s7">b&quot;&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">have_idna_2008</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NoIDNA2008</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">ulabel </span><span class="s4">= </span><span class="s1">idna</span><span class="s4">.</span><span class="s1">ulabel</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">uts_46</span><span class="s4">:</span>
                <span class="s1">ulabel </span><span class="s4">= </span><span class="s1">idna</span><span class="s4">.</span><span class="s1">uts46_remap</span><span class="s4">(</span><span class="s1">ulabel</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transitional</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">_escapify</span><span class="s4">(</span><span class="s1">ulabel</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s4">(</span><span class="s1">idna</span><span class="s4">.</span><span class="s1">IDNAError</span><span class="s4">, </span><span class="s1">UnicodeError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">IDNAException</span><span class="s4">(</span><span class="s1">idna_exception</span><span class="s4">=</span><span class="s1">e</span><span class="s4">)</span>


<span class="s1">IDNA_2003_Practical </span><span class="s4">= </span><span class="s1">IDNA2003Codec</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
<span class="s1">IDNA_2003_Strict </span><span class="s4">= </span><span class="s1">IDNA2003Codec</span><span class="s4">(</span><span class="s3">True</span><span class="s4">)</span>
<span class="s1">IDNA_2003 </span><span class="s4">= </span><span class="s1">IDNA_2003_Practical</span>
<span class="s1">IDNA_2008_Practical </span><span class="s4">= </span><span class="s1">IDNA2008Codec</span><span class="s4">(</span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
<span class="s1">IDNA_2008_UTS_46 </span><span class="s4">= </span><span class="s1">IDNA2008Codec</span><span class="s4">(</span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
<span class="s1">IDNA_2008_Strict </span><span class="s4">= </span><span class="s1">IDNA2008Codec</span><span class="s4">(</span><span class="s3">False</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">True</span><span class="s4">)</span>
<span class="s1">IDNA_2008_Transitional </span><span class="s4">= </span><span class="s1">IDNA2008Codec</span><span class="s4">(</span><span class="s3">True</span><span class="s4">, </span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
<span class="s1">IDNA_2008 </span><span class="s4">= </span><span class="s1">IDNA_2008_Practical</span>


<span class="s3">def </span><span class="s1">_validate_labels</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">, ...]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Check for empty labels in the middle of a label sequence, 
    labels that are too long, and for too many labels. 
 
    Raises ``dns.name.NameTooLong`` if the name as a whole is too long. 
 
    Raises ``dns.name.EmptyLabel`` if a label is empty (i.e. the root 
    label) and appears in a position other than the end of the label 
    sequence 
 
    &quot;&quot;&quot;</span>

    <span class="s1">l </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)</span>
    <span class="s1">total </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">i </span><span class="s4">= -</span><span class="s6">1</span>
    <span class="s1">j </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">labels</span><span class="s4">:</span>
        <span class="s1">ll </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
        <span class="s1">total </span><span class="s4">+= </span><span class="s1">ll </span><span class="s4">+ </span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">ll </span><span class="s4">&gt; </span><span class="s6">63</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">LabelTooLong</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">label </span><span class="s4">== </span><span class="s7">b&quot;&quot;</span><span class="s4">:</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s1">j</span>
        <span class="s1">j </span><span class="s4">+= </span><span class="s6">1</span>
    <span class="s3">if </span><span class="s1">total </span><span class="s4">&gt; </span><span class="s6">255</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NameTooLong</span>
    <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">i </span><span class="s4">!= </span><span class="s1">l </span><span class="s4">- </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">EmptyLabel</span>


<span class="s3">def </span><span class="s1">_maybe_convert_to_binary</span><span class="s4">(</span><span class="s1">label</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; bytes</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;If label is ``str``, convert it to ``bytes``.  If it is already 
    ``bytes`` just return it. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">label</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">label</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">()</span>
    <span class="s3">raise </span><span class="s1">ValueError  </span><span class="s0"># pragma: no cover</span>


<span class="s4">@</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">immutable</span><span class="s4">.</span><span class="s1">immutable</span>
<span class="s3">class </span><span class="s1">Name</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A DNS name. 
 
    The dns.name.Name class represents a DNS name as a tuple of 
    labels.  Each label is a ``bytes`` in DNS wire format.  Instances 
    of the class are immutable. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= [</span><span class="s5">&quot;labels&quot;</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]]):</span>
        <span class="s2">&quot;&quot;&quot;*labels* is any iterable whose values are ``str`` or ``bytes``.&quot;&quot;&quot;</span>

        <span class="s1">blabels </span><span class="s4">= [</span><span class="s1">_maybe_convert_to_binary</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">labels</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">labels </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">blabels</span><span class="s4">)</span>
        <span class="s1">_validate_labels</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__copy__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__deepcopy__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memo</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">, </span><span class="s1">memo</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># Names can be pickled</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s5">&quot;labels&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__setstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__setattr__</span><span class="s4">(</span><span class="s5">&quot;labels&quot;</span><span class="s4">, </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;labels&quot;</span><span class="s4">])</span>
        <span class="s1">_validate_labels</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">is_absolute</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Is the most significant label of this name the root label? 
 
        Returns a ``bool``. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">) &gt; </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] == </span><span class="s7">b&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">is_wild</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Is this name wild?  (I.e. Is the least significant label '*'?) 
 
        Returns a ``bool``. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">) &gt; </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s7">b&quot;*&quot;</span>

    <span class="s3">def </span><span class="s1">__hash__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a case-insensitive hash of the name. 
 
        Returns an ``int``. 
        &quot;&quot;&quot;</span>

        <span class="s1">h </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">label</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">():</span>
                <span class="s1">h </span><span class="s4">+= (</span><span class="s1">h </span><span class="s4">&lt;&lt; </span><span class="s6">3</span><span class="s4">) + </span><span class="s1">c</span>
        <span class="s3">return </span><span class="s1">h</span>

    <span class="s3">def </span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">NameRelation</span><span class="s4">, </span><span class="s1">int</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Compare two names, returning a 3-tuple 
        ``(relation, order, nlabels)``. 
 
        *relation* describes the relation ship between the names, 
        and is one of: ``dns.name.NameRelation.NONE``, 
        ``dns.name.NameRelation.SUPERDOMAIN``, ``dns.name.NameRelation.SUBDOMAIN``, 
        ``dns.name.NameRelation.EQUAL``, or ``dns.name.NameRelation.COMMONANCESTOR``. 
 
        *order* is &lt; 0 if *self* &lt; *other*, &gt; 0 if *self* &gt; *other*, and == 
        0 if *self* == *other*.  A relative name is always less than an 
        absolute name.  If both names have the same relativity, then 
        the DNSSEC order relation is used to order them. 
 
        *nlabels* is the number of significant labels that the two names 
        have in common. 
 
        Here are some examples.  Names ending in &quot;.&quot; are absolute names, 
        those not ending in &quot;.&quot; are relative names. 
 
        =============  =============  ===========  =====  ======= 
        self           other          relation     order  nlabels 
        =============  =============  ===========  =====  ======= 
        www.example.   www.example.   equal        0      3 
        www.example.   example.       subdomain    &gt; 0    2 
        example.       www.example.   superdomain  &lt; 0    2 
        example1.com.  example2.com.  common anc.  &lt; 0    2 
        example1       example2.      none         &lt; 0    0 
        example1.      example2       none         &gt; 0    0 
        =============  =============  ===========  =====  ======= 
        &quot;&quot;&quot;</span>

        <span class="s1">sabs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">()</span>
        <span class="s1">oabs </span><span class="s4">= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">sabs </span><span class="s4">!= </span><span class="s1">oabs</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">sabs</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">NONE</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>
        <span class="s1">l1 </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>
        <span class="s1">l2 </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">other</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>
        <span class="s1">ldiff </span><span class="s4">= </span><span class="s1">l1 </span><span class="s4">- </span><span class="s1">l2</span>
        <span class="s3">if </span><span class="s1">ldiff </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">l1</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">l2</span>

        <span class="s1">order </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s1">nlabels </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s1">namereln </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">NONE</span>
        <span class="s3">while </span><span class="s1">l </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">l </span><span class="s4">-= </span><span class="s6">1</span>
            <span class="s1">l1 </span><span class="s4">-= </span><span class="s6">1</span>
            <span class="s1">l2 </span><span class="s4">-= </span><span class="s6">1</span>
            <span class="s1">label1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s1">l1</span><span class="s4">].</span><span class="s1">lower</span><span class="s4">()</span>
            <span class="s1">label2 </span><span class="s4">= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s1">l2</span><span class="s4">].</span><span class="s1">lower</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">label1 </span><span class="s4">&lt; </span><span class="s1">label2</span><span class="s4">:</span>
                <span class="s1">order </span><span class="s4">= -</span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">nlabels </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s1">namereln </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">COMMONANCESTOR</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">namereln</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">nlabels</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">label1 </span><span class="s4">&gt; </span><span class="s1">label2</span><span class="s4">:</span>
                <span class="s1">order </span><span class="s4">= </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">nlabels </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s1">namereln </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">COMMONANCESTOR</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">namereln</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">nlabels</span><span class="s4">)</span>
            <span class="s1">nlabels </span><span class="s4">+= </span><span class="s6">1</span>
        <span class="s1">order </span><span class="s4">= </span><span class="s1">ldiff</span>
        <span class="s3">if </span><span class="s1">ldiff </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">namereln </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">SUPERDOMAIN</span>
        <span class="s3">elif </span><span class="s1">ldiff </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">namereln </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">SUBDOMAIN</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">namereln </span><span class="s4">= </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">EQUAL</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">namereln</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">nlabels</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">is_subdomain</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Is self a subdomain of other? 
 
        Note that the notion of subdomain includes equality, e.g. 
        &quot;dnspython.org&quot; is a subdomain of itself. 
 
        Returns a ``bool``. 
        &quot;&quot;&quot;</span>

        <span class="s4">(</span><span class="s1">nr</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">nr </span><span class="s4">== </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">SUBDOMAIN </span><span class="s3">or </span><span class="s1">nr </span><span class="s4">== </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">EQUAL</span><span class="s4">:</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">is_superdomain</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Is self a superdomain of other? 
 
        Note that the notion of superdomain includes equality, e.g. 
        &quot;dnspython.org&quot; is a superdomain of itself. 
 
        Returns a ``bool``. 
        &quot;&quot;&quot;</span>

        <span class="s4">(</span><span class="s1">nr</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">nr </span><span class="s4">== </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">SUPERDOMAIN </span><span class="s3">or </span><span class="s1">nr </span><span class="s4">== </span><span class="s1">NameRelation</span><span class="s4">.</span><span class="s1">EQUAL</span><span class="s4">:</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">canonicalize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a name which is equal to the current name, but is in 
        DNSSEC canonical form. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">Name</span><span class="s4">([</span><span class="s1">x</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">])</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">] == </span><span class="s6">0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__ne__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">] != </span><span class="s6">0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">__lt__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">] &lt; </span><span class="s6">0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__le__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">] &lt;= </span><span class="s6">0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__ge__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">] &gt;= </span><span class="s6">0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__gt__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fullcompare</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">] &gt; </span><span class="s6">0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">&quot;&lt;DNS name &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__str__</span><span class="s4">() + </span><span class="s5">&quot;&gt;&quot;</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">to_text</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_text</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">omit_final_dot</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Convert name to DNS text format. 
 
        *omit_final_dot* is a ``bool``.  If True, don't emit the final 
        dot (denoting the root label) for absolute names.  The default 
        is False. 
 
        Returns a ``str``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;@&quot;</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s7">b&quot;&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;.&quot;</span>
        <span class="s3">if </span><span class="s1">omit_final_dot </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span>
        <span class="s1">s </span><span class="s4">= </span><span class="s5">&quot;.&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">map</span><span class="s4">(</span><span class="s1">_escapify</span><span class="s4">, </span><span class="s1">l</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">s</span>

    <span class="s3">def </span><span class="s1">to_unicode</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">omit_final_dot</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">, </span><span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">IDNACodec</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Convert name to Unicode text format. 
 
        IDN ACE labels are converted to Unicode. 
 
        *omit_final_dot* is a ``bool``.  If True, don't emit the final 
        dot (denoting the root label) for absolute names.  The default 
        is False. 
        *idna_codec* specifies the IDNA encoder/decoder.  If None, the 
        dns.name.IDNA_2003_Practical encoder/decoder is used. 
        The IDNA_2003_Practical decoder does 
        not impose any policy, it just decodes punycode, so if you 
        don't want checking for compliance, you can use this decoder 
        for IDNA2008 as well. 
 
        Returns a ``str``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;@&quot;</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s7">b&quot;&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;.&quot;</span>
        <span class="s3">if </span><span class="s1">omit_final_dot </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span>
        <span class="s3">if </span><span class="s1">idna_codec </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">idna_codec </span><span class="s4">= </span><span class="s1">IDNA_2003_Practical</span>
        <span class="s3">return </span><span class="s5">&quot;.&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">([</span><span class="s1">idna_codec</span><span class="s4">.</span><span class="s1">decode</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">l</span><span class="s4">])</span>

    <span class="s3">def </span><span class="s1">to_digestable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s5">&quot;Name&quot;</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; bytes</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Convert name to a format suitable for digesting in hashes. 
 
        The name is canonicalized and converted to uncompressed wire 
        format.  All names in wire format are absolute.  If the name 
        is a relative name, then an origin must be supplied. 
 
        *origin* is a ``dns.name.Name`` or ``None``.  If the name is 
        relative and origin is not ``None``, then origin will be appended 
        to the name. 
 
        Raises ``dns.name.NeedAbsoluteNameOrOrigin`` if the name is 
        relative and no origin was provided. 
 
        Returns a ``bytes``. 
        &quot;&quot;&quot;</span>

        <span class="s1">digest </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">to_wire</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">=</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">canonicalize</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">digest </span><span class="s3">is not None</span>
        <span class="s3">return </span><span class="s1">digest</span>

    <span class="s3">def </span><span class="s1">to_wire</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">file</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">compress</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CompressType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s5">&quot;Name&quot;</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">canonicalize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Convert name to wire format, possibly compressing it. 
 
        *file* is the file where the name is emitted (typically an 
        io.BytesIO file).  If ``None`` (the default), a ``bytes`` 
        containing the wire name will be returned. 
 
        *compress*, a ``dict``, is the compression table to use.  If 
        ``None`` (the default), names will not be compressed.  Note that 
        the compression code assumes that compression offset 0 is the 
        start of *file*, and thus compression will not be correct 
        if this is not the case. 
 
        *origin* is a ``dns.name.Name`` or ``None``.  If the name is 
        relative and origin is not ``None``, then *origin* will be appended 
        to it. 
 
        *canonicalize*, a ``bool``, indicates whether the name should 
        be canonicalized; that is, converted to a format suitable for 
        digesting in hashes. 
 
        Raises ``dns.name.NeedAbsoluteNameOrOrigin`` if the name is 
        relative and no origin was provided. 
 
        Returns a ``bytes`` or ``None``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">file </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">out </span><span class="s4">= </span><span class="s1">bytearray</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">:</span>
                <span class="s1">out</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">))</span>
                <span class="s3">if </span><span class="s1">canonicalize</span><span class="s4">:</span>
                    <span class="s1">out </span><span class="s4">+= </span><span class="s1">label</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">out </span><span class="s4">+= </span><span class="s1">label</span>
            <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
                <span class="s3">if </span><span class="s1">origin </span><span class="s3">is None or not </span><span class="s1">origin</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
                    <span class="s3">raise </span><span class="s1">NeedAbsoluteNameOrOrigin</span>
                <span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">origin</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">:</span>
                    <span class="s1">out</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">))</span>
                    <span class="s3">if </span><span class="s1">canonicalize</span><span class="s4">:</span>
                        <span class="s1">out </span><span class="s4">+= </span><span class="s1">label</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">out </span><span class="s4">+= </span><span class="s1">label</span>
            <span class="s3">return </span><span class="s1">bytes</span><span class="s4">(</span><span class="s1">out</span><span class="s4">)</span>

        <span class="s1">labels</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">]</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">origin </span><span class="s3">is None or not </span><span class="s1">origin</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
                <span class="s3">raise </span><span class="s1">NeedAbsoluteNameOrOrigin</span>
            <span class="s1">labels </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>
            <span class="s1">labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">labels </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">labels</span><span class="s4">:</span>
            <span class="s1">n </span><span class="s4">= </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">[</span><span class="s1">i</span><span class="s4">:])</span>
            <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s3">if </span><span class="s1">compress </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">pos </span><span class="s4">= </span><span class="s1">compress</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">pos </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">pos </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s6">0xC000 </span><span class="s4">+ </span><span class="s1">pos</span>
                <span class="s1">s </span><span class="s4">= </span><span class="s1">struct</span><span class="s4">.</span><span class="s1">pack</span><span class="s4">(</span><span class="s5">&quot;!H&quot;</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
                <span class="s1">file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">s</span><span class="s4">)</span>
                <span class="s3">break</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">compress </span><span class="s3">is not None and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">n</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
                    <span class="s1">pos </span><span class="s4">= </span><span class="s1">file</span><span class="s4">.</span><span class="s1">tell</span><span class="s4">()</span>
                    <span class="s3">if </span><span class="s1">pos </span><span class="s4">&lt;= </span><span class="s6">0x3FFF</span><span class="s4">:</span>
                        <span class="s1">compress</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">pos</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
                <span class="s1">file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">struct</span><span class="s4">.</span><span class="s1">pack</span><span class="s4">(</span><span class="s5">&quot;!B&quot;</span><span class="s4">, </span><span class="s1">l</span><span class="s4">))</span>
                <span class="s3">if </span><span class="s1">l </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">canonicalize</span><span class="s4">:</span>
                        <span class="s1">file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">label</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">())</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">__len__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;The length of the name (in labels). 
 
        Returns an ``int``. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s1">index</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__sub__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">split</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s5">&quot;Name&quot;</span><span class="s4">, </span><span class="s5">&quot;Name&quot;</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Split a name into a prefix and suffix names at the specified depth. 
 
        *depth* is an ``int`` specifying the number of labels in the suffix 
 
        Raises ``ValueError`` if *depth* was not &gt;= 0 and &lt;= the length of the 
        name. 
 
        Returns the tuple ``(prefix, suffix)``. 
        &quot;&quot;&quot;</span>

        <span class="s1">l </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">depth </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">depth </span><span class="s4">== </span><span class="s1">l</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">depth </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">depth </span><span class="s4">&gt; </span><span class="s1">l</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;depth must be &gt;= 0 and &lt;= the length of the name&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">Name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">[:-</span><span class="s1">depth</span><span class="s4">]), </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">[-</span><span class="s1">depth</span><span class="s4">:]))</span>

    <span class="s3">def </span><span class="s1">concatenate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new name which is the concatenation of self and other. 
 
        Raises ``dns.name.AbsoluteConcatenation`` if the name is 
        absolute and *other* is not the empty name. 
 
        Returns a ``dns.name.Name``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">() </span><span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">other</span><span class="s4">) &gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">AbsoluteConcatenation</span>
        <span class="s1">labels </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>
        <span class="s1">labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">other</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">relativize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;If the name is a subdomain of *origin*, return a new name which is 
        the name relative to origin.  Otherwise return the name. 
 
        For example, relativizing ``www.dnspython.org.`` to origin 
        ``dnspython.org.`` returns the name ``www``.  Relativizing ``example.`` 
        to origin ``dnspython.org.`` returns ``example.``. 
 
        Returns a ``dns.name.Name``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">origin </span><span class="s3">is not None and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_subdomain</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">[: -</span><span class="s1">len</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">derelativize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;If the name is a relative name, return a new name which is the 
        concatenation of the name and origin.  Otherwise return the name. 
 
        For example, derelativizing ``www`` to origin ``dnspython.org.`` 
        returns the name ``www.dnspython.org.``.  Derelativizing ``example.`` 
        to origin ``dnspython.org.`` returns ``example.``. 
 
        Returns a ``dns.name.Name``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">choose_relativity</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s5">&quot;Name&quot;</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">relativize</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a name with the relativity desired by the caller. 
 
        If *origin* is ``None``, then the name is returned. 
        Otherwise, if *relativize* is ``True`` the name is 
        relativized, and if *relativize* is ``False`` the name is 
        derelativized. 
 
        Returns a ``dns.name.Name``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">origin</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">relativize</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">derelativize</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">parent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return the parent of the name. 
 
        For example, the parent of ``www.dnspython.org.`` is ``dnspython.org``. 
 
        Raises ``dns.name.NoParent`` if the name is either the root name or the 
        empty name, and thus has no parent. 
 
        Returns a ``dns.name.Name``. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self </span><span class="s4">== </span><span class="s1">root </span><span class="s3">or </span><span class="s1">self </span><span class="s4">== </span><span class="s1">empty</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NoParent</span>
        <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:])</span>

    <span class="s3">def </span><span class="s1">predecessor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">, </span><span class="s1">prefix_ok</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return the maximal predecessor of *name* in the DNSSEC ordering in the zone 
        whose origin is *origin*, or return the longest name under *origin* if the 
        name is origin (i.e. wrap around to the longest name, which may still be 
        *origin* due to length considerations. 
 
        The relativity of the name is preserved, so if this name is relative 
        then the method will return a relative name, and likewise if this name 
        is absolute then the predecessor will be absolute. 
 
        *prefix_ok* indicates if prefixing labels is allowed, and 
        defaults to ``True``.  Normally it is good to allow this, but if computing 
        a maximal predecessor at a zone cut point then ``False`` must be specified. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_handle_relativity_and_call</span><span class="s4">(</span>
            <span class="s1">_absolute_predecessor</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">, </span><span class="s1">prefix_ok</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">successor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s5">&quot;Name&quot;</span><span class="s4">, </span><span class="s1">prefix_ok</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s5">&quot;Name&quot;</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return the minimal successor of *name* in the DNSSEC ordering in the zone 
        whose origin is *origin*, or return *origin* if the successor cannot be 
        computed due to name length limitations. 
 
        Note that *origin* is returned in the &quot;too long&quot; cases because wrapping 
        around to the origin is how NSEC records express &quot;end of the zone&quot;. 
 
        The relativity of the name is preserved, so if this name is relative 
        then the method will return a relative name, and likewise if this name 
        is absolute then the successor will be absolute. 
 
        *prefix_ok* indicates if prefixing a new minimal label is allowed, and 
        defaults to ``True``.  Normally it is good to allow this, but if computing 
        a minimal successor at a zone cut point then ``False`` must be specified. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_handle_relativity_and_call</span><span class="s4">(</span><span class="s1">_absolute_successor</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">, </span><span class="s1">prefix_ok</span><span class="s4">)</span>


<span class="s0">#: The root name, '.'</span>
<span class="s1">root </span><span class="s4">= </span><span class="s1">Name</span><span class="s4">([</span><span class="s7">b&quot;&quot;</span><span class="s4">])</span>

<span class="s0">#: The empty name.</span>
<span class="s1">empty </span><span class="s4">= </span><span class="s1">Name</span><span class="s4">([])</span>


<span class="s3">def </span><span class="s1">from_unicode</span><span class="s4">(</span>
    <span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Name</span><span class="s4">] = </span><span class="s1">root</span><span class="s4">, </span><span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">IDNACodec</span><span class="s4">] = </span><span class="s3">None</span>
<span class="s4">) </span><span class="s1">-&gt; Name</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Convert unicode text into a Name object. 
 
    Labels are encoded in IDN ACE form according to rules specified by 
    the IDNA codec. 
 
    *text*, a ``str``, is the text to convert into a name. 
 
    *origin*, a ``dns.name.Name``, specifies the origin to 
    append to non-absolute names.  The default is the root name. 
 
    *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA 
    encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder 
    is used. 
 
    Returns a ``dns.name.Name``. 
    &quot;&quot;&quot;</span>

    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;input to from_unicode() must be a unicode string&quot;</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s4">(</span><span class="s1">origin </span><span class="s3">is None or </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;origin must be a Name or None&quot;</span><span class="s4">)</span>
    <span class="s1">labels </span><span class="s4">= []</span>
    <span class="s1">label </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
    <span class="s1">escaping </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">edigits </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">total </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">if </span><span class="s1">idna_codec </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">idna_codec </span><span class="s4">= </span><span class="s1">IDNA_2003</span>
    <span class="s3">if </span><span class="s1">text </span><span class="s4">== </span><span class="s5">&quot;@&quot;</span><span class="s4">:</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">text</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">text </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;.&quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\u3002</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\uff0e</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\uff61</span><span class="s5">&quot;</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">Name</span><span class="s4">([</span><span class="s7">b&quot;&quot;</span><span class="s4">])  </span><span class="s0"># no Unicode &quot;u&quot; on this constant!</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">text</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">escaping</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">edigits </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">():</span>
                        <span class="s1">total </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                        <span class="s1">edigits </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">label </span><span class="s4">+= </span><span class="s1">c</span>
                        <span class="s1">escaping </span><span class="s4">= </span><span class="s3">False</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">if not </span><span class="s1">c</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">():</span>
                        <span class="s3">raise </span><span class="s1">BadEscape</span>
                    <span class="s1">total </span><span class="s4">*= </span><span class="s6">10</span>
                    <span class="s1">total </span><span class="s4">+= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                    <span class="s1">edigits </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">if </span><span class="s1">edigits </span><span class="s4">== </span><span class="s6">3</span><span class="s4">:</span>
                        <span class="s1">escaping </span><span class="s4">= </span><span class="s3">False</span>
                        <span class="s1">label </span><span class="s4">+= </span><span class="s1">chr</span><span class="s4">(</span><span class="s1">total</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">c </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;.&quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\u3002</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\uff0e</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\uff61</span><span class="s5">&quot;</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">EmptyLabel</span>
                <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">idna_codec</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s1">label</span><span class="s4">))</span>
                <span class="s1">label </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
            <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s5">&quot;</span><span class="s3">\\</span><span class="s5">&quot;</span><span class="s4">:</span>
                <span class="s1">escaping </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s1">edigits </span><span class="s4">= </span><span class="s6">0</span>
                <span class="s1">total </span><span class="s4">= </span><span class="s6">0</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">label </span><span class="s4">+= </span><span class="s1">c</span>
        <span class="s3">if </span><span class="s1">escaping</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">BadEscape</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">) &gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">idna_codec</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s1">label</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s7">b&quot;&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">) == </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">labels</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] != </span><span class="s7">b&quot;&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">origin </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">is_all_ascii</span><span class="s4">(</span><span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">text</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">ord</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) &gt; </span><span class="s6">0x7F</span><span class="s4">:</span>
            <span class="s3">return False</span>
    <span class="s3">return True</span>


<span class="s3">def </span><span class="s1">from_text</span><span class="s4">(</span>
    <span class="s1">text</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">str</span><span class="s4">],</span>
    <span class="s1">origin</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Name</span><span class="s4">] = </span><span class="s1">root</span><span class="s4">,</span>
    <span class="s1">idna_codec</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">IDNACodec</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Name</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Convert text into a Name object. 
 
    *text*, a ``bytes`` or ``str``, is the text to convert into a name. 
 
    *origin*, a ``dns.name.Name``, specifies the origin to 
    append to non-absolute names.  The default is the root name. 
 
    *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA 
    encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder 
    is used. 
 
    Returns a ``dns.name.Name``. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">is_all_ascii</span><span class="s4">(</span><span class="s1">text</span><span class="s4">):</span>
            <span class="s0"># Some codepoint in the input text is &gt; 127, so IDNA applies.</span>
            <span class="s3">return </span><span class="s1">from_unicode</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">, </span><span class="s1">idna_codec</span><span class="s4">)</span>
        <span class="s0"># The input is all ASCII, so treat this like an ordinary non-IDNA</span>
        <span class="s0"># domain name.  Note that &quot;all ASCII&quot; is about the input text,</span>
        <span class="s0"># not the codepoints in the domain name.  E.g. if text has value</span>
        <span class="s0">#</span>
        <span class="s0"># r'\150\151\152\153\154\155\156\157\158\159'</span>
        <span class="s0">#</span>
        <span class="s0"># then it's still &quot;all ASCII&quot; even though the domain name has</span>
        <span class="s0"># codepoints &gt; 127.</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s5">&quot;ascii&quot;</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;input to from_text() must be a string&quot;</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s4">(</span><span class="s1">origin </span><span class="s3">is None or </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;origin must be a Name or None&quot;</span><span class="s4">)</span>
    <span class="s1">labels </span><span class="s4">= []</span>
    <span class="s1">label </span><span class="s4">= </span><span class="s7">b&quot;&quot;</span>
    <span class="s1">escaping </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">edigits </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">total </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">if </span><span class="s1">text </span><span class="s4">== </span><span class="s7">b&quot;@&quot;</span><span class="s4">:</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s7">b&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">text</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">text </span><span class="s4">== </span><span class="s7">b&quot;.&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">Name</span><span class="s4">([</span><span class="s7">b&quot;&quot;</span><span class="s4">])</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">text</span><span class="s4">:</span>
            <span class="s1">byte_ </span><span class="s4">= </span><span class="s1">struct</span><span class="s4">.</span><span class="s1">pack</span><span class="s4">(</span><span class="s5">&quot;!B&quot;</span><span class="s4">, </span><span class="s1">c</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">escaping</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">edigits </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">byte_</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">():</span>
                        <span class="s1">total </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">byte_</span><span class="s4">)</span>
                        <span class="s1">edigits </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">label </span><span class="s4">+= </span><span class="s1">byte_</span>
                        <span class="s1">escaping </span><span class="s4">= </span><span class="s3">False</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">if not </span><span class="s1">byte_</span><span class="s4">.</span><span class="s1">isdigit</span><span class="s4">():</span>
                        <span class="s3">raise </span><span class="s1">BadEscape</span>
                    <span class="s1">total </span><span class="s4">*= </span><span class="s6">10</span>
                    <span class="s1">total </span><span class="s4">+= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">byte_</span><span class="s4">)</span>
                    <span class="s1">edigits </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s3">if </span><span class="s1">edigits </span><span class="s4">== </span><span class="s6">3</span><span class="s4">:</span>
                        <span class="s1">escaping </span><span class="s4">= </span><span class="s3">False</span>
                        <span class="s1">label </span><span class="s4">+= </span><span class="s1">struct</span><span class="s4">.</span><span class="s1">pack</span><span class="s4">(</span><span class="s5">&quot;!B&quot;</span><span class="s4">, </span><span class="s1">total</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">byte_ </span><span class="s4">== </span><span class="s7">b&quot;.&quot;</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">EmptyLabel</span>
                <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
                <span class="s1">label </span><span class="s4">= </span><span class="s7">b&quot;&quot;</span>
            <span class="s3">elif </span><span class="s1">byte_ </span><span class="s4">== </span><span class="s7">b&quot;</span><span class="s3">\\</span><span class="s7">&quot;</span><span class="s4">:</span>
                <span class="s1">escaping </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s1">edigits </span><span class="s4">= </span><span class="s6">0</span>
                <span class="s1">total </span><span class="s4">= </span><span class="s6">0</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">label </span><span class="s4">+= </span><span class="s1">byte_</span>
        <span class="s3">if </span><span class="s1">escaping</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">BadEscape</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">) &gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s7">b&quot;&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">) == </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">labels</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] != </span><span class="s7">b&quot;&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">origin </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)</span>


<span class="s0"># we need 'dns.wire.Parser' quoted as dns.name and dns.wire depend on each other.</span>


<span class="s3">def </span><span class="s1">from_wire_parser</span><span class="s4">(</span><span class="s1">parser</span><span class="s4">: </span><span class="s5">&quot;dns.wire.Parser&quot;</span><span class="s4">) </span><span class="s1">-&gt; Name</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Convert possibly compressed wire format into a Name. 
 
    *parser* is a dns.wire.Parser. 
 
    Raises ``dns.name.BadPointer`` if a compression pointer did not 
    point backwards in the message. 
 
    Raises ``dns.name.BadLabelType`` if an invalid label type was encountered. 
 
    Returns a ``dns.name.Name`` 
    &quot;&quot;&quot;</span>

    <span class="s1">labels </span><span class="s4">= []</span>
    <span class="s1">biggest_pointer </span><span class="s4">= </span><span class="s1">parser</span><span class="s4">.</span><span class="s1">current</span>
    <span class="s3">with </span><span class="s1">parser</span><span class="s4">.</span><span class="s1">restore_furthest</span><span class="s4">():</span>
        <span class="s1">count </span><span class="s4">= </span><span class="s1">parser</span><span class="s4">.</span><span class="s1">get_uint8</span><span class="s4">()</span>
        <span class="s3">while </span><span class="s1">count </span><span class="s4">!= </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">count </span><span class="s4">&lt; </span><span class="s6">64</span><span class="s4">:</span>
                <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">parser</span><span class="s4">.</span><span class="s1">get_bytes</span><span class="s4">(</span><span class="s1">count</span><span class="s4">))</span>
            <span class="s3">elif </span><span class="s1">count </span><span class="s4">&gt;= </span><span class="s6">192</span><span class="s4">:</span>
                <span class="s1">current </span><span class="s4">= (</span><span class="s1">count </span><span class="s4">&amp; </span><span class="s6">0x3F</span><span class="s4">) * </span><span class="s6">256 </span><span class="s4">+ </span><span class="s1">parser</span><span class="s4">.</span><span class="s1">get_uint8</span><span class="s4">()</span>
                <span class="s3">if </span><span class="s1">current </span><span class="s4">&gt;= </span><span class="s1">biggest_pointer</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">BadPointer</span>
                <span class="s1">biggest_pointer </span><span class="s4">= </span><span class="s1">current</span>
                <span class="s1">parser</span><span class="s4">.</span><span class="s1">seek</span><span class="s4">(</span><span class="s1">current</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">BadLabelType</span>
            <span class="s1">count </span><span class="s4">= </span><span class="s1">parser</span><span class="s4">.</span><span class="s1">get_uint8</span><span class="s4">()</span>
        <span class="s1">labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s7">b&quot;&quot;</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">from_wire</span><span class="s4">(</span><span class="s1">message</span><span class="s4">: </span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">current</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Convert possibly compressed wire format into a Name. 
 
    *message* is a ``bytes`` containing an entire DNS message in DNS 
    wire form. 
 
    *current*, an ``int``, is the offset of the beginning of the name 
    from the start of the message 
 
    Raises ``dns.name.BadPointer`` if a compression pointer did not 
    point backwards in the message. 
 
    Raises ``dns.name.BadLabelType`` if an invalid label type was encountered. 
 
    Returns a ``(dns.name.Name, int)`` tuple consisting of the name 
    that was read and the number of bytes of the wire format message 
    which were consumed reading it. 
    &quot;&quot;&quot;</span>

    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">message</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;input to from_wire() must be a byte string&quot;</span><span class="s4">)</span>
    <span class="s1">parser </span><span class="s4">= </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">wire</span><span class="s4">.</span><span class="s1">Parser</span><span class="s4">(</span><span class="s1">message</span><span class="s4">, </span><span class="s1">current</span><span class="s4">)</span>
    <span class="s1">name </span><span class="s4">= </span><span class="s1">from_wire_parser</span><span class="s4">(</span><span class="s1">parser</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">parser</span><span class="s4">.</span><span class="s1">current </span><span class="s4">- </span><span class="s1">current</span><span class="s4">)</span>


<span class="s0"># RFC 4471 Support</span>

<span class="s1">_MINIMAL_OCTET </span><span class="s4">= </span><span class="s7">b&quot;</span><span class="s3">\x00</span><span class="s7">&quot;</span>
<span class="s1">_MINIMAL_OCTET_VALUE </span><span class="s4">= </span><span class="s1">ord</span><span class="s4">(</span><span class="s1">_MINIMAL_OCTET</span><span class="s4">)</span>
<span class="s1">_SUCCESSOR_PREFIX </span><span class="s4">= </span><span class="s1">Name</span><span class="s4">([</span><span class="s1">_MINIMAL_OCTET</span><span class="s4">])</span>
<span class="s1">_MAXIMAL_OCTET </span><span class="s4">= </span><span class="s7">b&quot;</span><span class="s3">\xff</span><span class="s7">&quot;</span>
<span class="s1">_MAXIMAL_OCTET_VALUE </span><span class="s4">= </span><span class="s1">ord</span><span class="s4">(</span><span class="s1">_MAXIMAL_OCTET</span><span class="s4">)</span>
<span class="s1">_AT_SIGN_VALUE </span><span class="s4">= </span><span class="s1">ord</span><span class="s4">(</span><span class="s5">&quot;@&quot;</span><span class="s4">)</span>
<span class="s1">_LEFT_SQUARE_BRACKET_VALUE </span><span class="s4">= </span><span class="s1">ord</span><span class="s4">(</span><span class="s5">&quot;[&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_wire_length</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">functools</span><span class="s4">.</span><span class="s1">reduce</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">v</span><span class="s4">, </span><span class="s1">x</span><span class="s4">: </span><span class="s1">v </span><span class="s4">+ </span><span class="s1">len</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) + </span><span class="s6">1</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_pad_to_max_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">):</span>
    <span class="s1">needed </span><span class="s4">= </span><span class="s6">255 </span><span class="s4">- </span><span class="s1">_wire_length</span><span class="s4">(</span><span class="s1">name</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>
    <span class="s1">new_labels </span><span class="s4">= []</span>
    <span class="s3">while </span><span class="s1">needed </span><span class="s4">&gt; </span><span class="s6">64</span><span class="s4">:</span>
        <span class="s1">new_labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">_MAXIMAL_OCTET </span><span class="s4">* </span><span class="s6">63</span><span class="s4">)</span>
        <span class="s1">needed </span><span class="s4">-= </span><span class="s6">64</span>
    <span class="s3">if </span><span class="s1">needed </span><span class="s4">&gt;= </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s1">new_labels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">_MAXIMAL_OCTET </span><span class="s4">* (</span><span class="s1">needed </span><span class="s4">- </span><span class="s6">1</span><span class="s4">))</span>
    <span class="s0"># Note we're already maximal in the needed == 1 case as while we'd like</span>
    <span class="s0"># to add one more byte as a new label, we can't, as adding a new non-empty</span>
    <span class="s0"># label requires at least 2 bytes.</span>
    <span class="s1">new_labels </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">reversed</span><span class="s4">(</span><span class="s1">new_labels</span><span class="s4">))</span>
    <span class="s1">new_labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">name</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">new_labels</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_pad_to_max_label</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">suffix_labels</span><span class="s4">):</span>
    <span class="s1">length </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>
    <span class="s0"># We have to subtract one here to account for the length byte of label.</span>
    <span class="s1">remaining </span><span class="s4">= </span><span class="s6">255 </span><span class="s4">- </span><span class="s1">_wire_length</span><span class="s4">(</span><span class="s1">suffix_labels</span><span class="s4">) - </span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span>
    <span class="s3">if </span><span class="s1">remaining </span><span class="s4">&lt;= </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s0"># Shouldn't happen!</span>
        <span class="s3">return </span><span class="s1">label</span>
    <span class="s1">needed </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s6">63 </span><span class="s4">- </span><span class="s1">length</span><span class="s4">, </span><span class="s1">remaining</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">label </span><span class="s4">+ </span><span class="s1">_MAXIMAL_OCTET </span><span class="s4">* </span><span class="s1">needed</span>


<span class="s3">def </span><span class="s1">_absolute_predecessor</span><span class="s4">(</span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">, </span><span class="s1">prefix_ok</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Name</span><span class="s4">:</span>
    <span class="s0"># This is the RFC 4471 predecessor algorithm using the &quot;absolute method&quot; of section</span>
    <span class="s0"># 3.1.1.</span>
    <span class="s0">#</span>
    <span class="s0"># Our caller must ensure that the name and origin are absolute, and that name is a</span>
    <span class="s0"># subdomain of origin.</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s4">== </span><span class="s1">origin</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_pad_to_max_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
    <span class="s1">least_significant_label </span><span class="s4">= </span><span class="s1">name</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">least_significant_label </span><span class="s4">== </span><span class="s1">_MINIMAL_OCTET</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">name</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">()</span>
    <span class="s1">least_octet </span><span class="s4">= </span><span class="s1">least_significant_label</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">suffix_labels </span><span class="s4">= </span><span class="s1">name</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:]</span>
    <span class="s3">if </span><span class="s1">least_octet </span><span class="s4">== </span><span class="s1">_MINIMAL_OCTET_VALUE</span><span class="s4">:</span>
        <span class="s1">new_labels </span><span class="s4">= [</span><span class="s1">least_significant_label</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">]]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">octets </span><span class="s4">= </span><span class="s1">bytearray</span><span class="s4">(</span><span class="s1">least_significant_label</span><span class="s4">)</span>
        <span class="s1">octet </span><span class="s4">= </span><span class="s1">octets</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">octet </span><span class="s4">== </span><span class="s1">_LEFT_SQUARE_BRACKET_VALUE</span><span class="s4">:</span>
            <span class="s1">octet </span><span class="s4">= </span><span class="s1">_AT_SIGN_VALUE</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">octet </span><span class="s4">-= </span><span class="s6">1</span>
        <span class="s1">octets</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] = </span><span class="s1">octet</span>
        <span class="s1">least_significant_label </span><span class="s4">= </span><span class="s1">bytes</span><span class="s4">(</span><span class="s1">octets</span><span class="s4">)</span>
        <span class="s1">new_labels </span><span class="s4">= [</span><span class="s1">_pad_to_max_label</span><span class="s4">(</span><span class="s1">least_significant_label</span><span class="s4">, </span><span class="s1">suffix_labels</span><span class="s4">)]</span>
    <span class="s1">new_labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">suffix_labels</span><span class="s4">)</span>
    <span class="s1">name </span><span class="s4">= </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">new_labels</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">prefix_ok</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_pad_to_max_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">name</span>


<span class="s3">def </span><span class="s1">_absolute_successor</span><span class="s4">(</span><span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">, </span><span class="s1">prefix_ok</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Name</span><span class="s4">:</span>
    <span class="s0"># This is the RFC 4471 successor algorithm using the &quot;absolute method&quot; of section</span>
    <span class="s0"># 3.1.2.</span>
    <span class="s0">#</span>
    <span class="s0"># Our caller must ensure that the name and origin are absolute, and that name is a</span>
    <span class="s0"># subdomain of origin.</span>
    <span class="s3">if </span><span class="s1">prefix_ok</span><span class="s4">:</span>
        <span class="s0"># Try prefixing \000 as new label</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_SUCCESSOR_PREFIX</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">NameTooLong</span><span class="s4">:</span>
            <span class="s3">pass</span>
    <span class="s3">while </span><span class="s1">name </span><span class="s4">!= </span><span class="s1">origin</span><span class="s4">:</span>
        <span class="s0"># Try extending the least significant label.</span>
        <span class="s1">least_significant_label </span><span class="s4">= </span><span class="s1">name</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">least_significant_label</span><span class="s4">) &lt; </span><span class="s6">63</span><span class="s4">:</span>
            <span class="s0"># We may be able to extend the least label with a minimal additional byte.</span>
            <span class="s0"># This is only &quot;may&quot; because we could have a maximal length name even though</span>
            <span class="s0"># the least significant label isn't maximally long.</span>
            <span class="s1">new_labels </span><span class="s4">= [</span><span class="s1">least_significant_label </span><span class="s4">+ </span><span class="s1">_MINIMAL_OCTET</span><span class="s4">]</span>
            <span class="s1">new_labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">name</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:])</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">Name</span><span class="s4">(</span><span class="s1">new_labels</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">dns</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">NameTooLong</span><span class="s4">:</span>
                <span class="s3">pass</span>
        <span class="s0"># We can't extend the label either, so we'll try to increment the least</span>
        <span class="s0"># signficant non-maximal byte in it.</span>
        <span class="s1">octets </span><span class="s4">= </span><span class="s1">bytearray</span><span class="s4">(</span><span class="s1">least_significant_label</span><span class="s4">)</span>
        <span class="s0"># We do this reversed iteration with an explicit indexing variable because</span>
        <span class="s0"># if we find something to increment, we're going to want to truncate everything</span>
        <span class="s0"># to the right of it.</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">octets</span><span class="s4">) - </span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">):</span>
            <span class="s1">octet </span><span class="s4">= </span><span class="s1">octets</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">octet </span><span class="s4">== </span><span class="s1">_MAXIMAL_OCTET_VALUE</span><span class="s4">:</span>
                <span class="s0"># We can't increment this, so keep looking.</span>
                <span class="s3">continue</span>
            <span class="s0"># Finally, something we can increment.  We have to apply a special rule for</span>
            <span class="s0"># incrementing &quot;@&quot;, sending it to &quot;[&quot;, because RFC 4034 6.1 says that when</span>
            <span class="s0"># comparing names, uppercase letters compare as if they were their</span>
            <span class="s0"># lower-case equivalents. If we increment &quot;@&quot; to &quot;A&quot;, then it would compare</span>
            <span class="s0"># as &quot;a&quot;, which is after &quot;[&quot;, &quot;\&quot;, &quot;]&quot;, &quot;^&quot;, &quot;_&quot;, and &quot;`&quot;, so we would have</span>
            <span class="s0"># skipped the most minimal successor, namely &quot;[&quot;.</span>
            <span class="s3">if </span><span class="s1">octet </span><span class="s4">== </span><span class="s1">_AT_SIGN_VALUE</span><span class="s4">:</span>
                <span class="s1">octet </span><span class="s4">= </span><span class="s1">_LEFT_SQUARE_BRACKET_VALUE</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">octet </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s1">octets</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">octet</span>
            <span class="s0"># We can now truncate all of the maximal values we skipped (if any)</span>
            <span class="s1">new_labels </span><span class="s4">= [</span><span class="s1">bytes</span><span class="s4">(</span><span class="s1">octets</span><span class="s4">[: </span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">])]</span>
            <span class="s1">new_labels</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">name</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:])</span>
            <span class="s0"># We haven't changed the length of the name, so the Name constructor will</span>
            <span class="s0"># always work.</span>
            <span class="s3">return </span><span class="s1">Name</span><span class="s4">(</span><span class="s1">new_labels</span><span class="s4">)</span>
        <span class="s0"># We couldn't increment, so chop off the least significant label and try</span>
        <span class="s0"># again.</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">name</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">()</span>

    <span class="s0"># We couldn't increment at all, so return the origin, as wrapping around is the</span>
    <span class="s0"># DNSSEC way.</span>
    <span class="s3">return </span><span class="s1">origin</span>


<span class="s3">def </span><span class="s1">_handle_relativity_and_call</span><span class="s4">(</span>
    <span class="s1">function</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Name</span><span class="s4">, </span><span class="s1">Name</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">], </span><span class="s1">Name</span><span class="s4">],</span>
    <span class="s1">name</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">,</span>
    <span class="s1">origin</span><span class="s4">: </span><span class="s1">Name</span><span class="s4">,</span>
    <span class="s1">prefix_ok</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Name</span><span class="s4">:</span>
    <span class="s0"># Make &quot;name&quot; absolute if needed, ensure that the origin is absolute,</span>
    <span class="s0"># call function(), and then relativize the result if needed.</span>
    <span class="s3">if not </span><span class="s1">origin</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">():</span>
        <span class="s3">raise </span><span class="s1">NeedAbsoluteNameOrOrigin</span>
    <span class="s1">relative </span><span class="s4">= </span><span class="s3">not </span><span class="s1">name</span><span class="s4">.</span><span class="s1">is_absolute</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">relative</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">name</span><span class="s4">.</span><span class="s1">derelativize</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
    <span class="s3">elif not </span><span class="s1">name</span><span class="s4">.</span><span class="s1">is_subdomain</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NeedSubdomainOfOrigin</span>
    <span class="s1">result_name </span><span class="s4">= </span><span class="s1">function</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">, </span><span class="s1">prefix_ok</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">relative</span><span class="s4">:</span>
        <span class="s1">result_name </span><span class="s4">= </span><span class="s1">result_name</span><span class="s4">.</span><span class="s1">relativize</span><span class="s4">(</span><span class="s1">origin</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">result_name</span>
</pre>
</body>
</html>